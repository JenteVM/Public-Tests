<!--
  NOTE: This file was fully generated by AI (ChatGPT).
  For testing purposes only.
  Adjusted: token masking, improved panels, copy feedback, soft auto-refresh.
-->

<!DOCTYPE html>
<html>
<head>
  <title>Full Test Console</title>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <link rel="icon" href="../favicon.svg" type="image/svg+xml" />
  <style>
    :root {
      --bg: #f6f4f1;
      --text: #1f2328;
      --muted: #5b6168;
      --card: #ffffff;
      --accent: #0b66c3;
      --accent-hover: #094f98;
      --border: rgba(0,0,0,0.08);
      --shadow: 0 20px 50px rgba(17, 24, 39, 0.12);
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Trebuchet MS", "Segoe UI", Arial, sans-serif;
      margin: 0;
      padding: 28px 32px 48px;
      line-height: 1.55;
      background: radial-gradient(circle at top, #ffffff 0%, #f6f4f1 45%, #efe8df 100%);
      color: var(--text);
      transition: background 0.3s, color 0.3s;
    }
    form, .panel {
      border: 1px solid var(--border);
      padding: 16px 18px;
      margin-bottom: 20px;
      border-radius: 18px;
      background: var(--card);
      transition: background 0.3s, border-color 0.3s, box-shadow 0.3s;
      box-shadow: var(--shadow);
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    label {
      font-weight: 600;
    }
    input, select {
      margin-bottom: 10px;
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #ffffff;
      font-family: inherit;
    }
    button {
      cursor: pointer;
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid rgba(11, 102, 195, 0.3);
      background: var(--accent);
      color: #ffffff;
      font-weight: 600;
      transition: transform 0.15s ease, background 0.15s ease;
    }
    button:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }
    .section {
      margin-bottom: 25px;
    }
  /* userSection visibility controlled via JS; no default display block */
    details.panel {
      background: var(--card);
      padding: 0;
      overflow: hidden;
    }
    details.panel summary {
      list-style: none;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 12px 16px;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(11, 102, 195, 0.08);
      border-bottom: 1px solid var(--border);
    }
    details.panel[open] summary {
      background: rgba(11, 102, 195, 0.12);
    }
    details.panel summary::-webkit-details-marker { display:none; }
    details.panel .content { padding: 16px 16px 10px; }
    details.panel .content h3:first-child { margin-top:0; }
    .badge {
      display:inline-block; padding:2px 8px; border-radius:20px; font-size:11px; background: rgba(11, 102, 195, 0.2); font-weight:600; color: var(--accent);
    }
    body.dark .badge { background:#444; }
    .token-masked { font-family: monospace; letter-spacing: 1px; }
    .inline-controls button { margin-left:6px; }
    .status-line { line-height:1.3; }
    /* Details open/close animation */
    details.panel .content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.35s ease;
    }
    details.panel[open] .content {
      max-height: 2000px; /* allow taller content so fields/buttons aren't clipped */
      overflow: visible;
    }
    .validate-busy {
      opacity: 0.6;
      pointer-events: none;
    }
    .spinner-inline {
      display:inline-block; width:14px; height:14px; border:2px solid #999; border-top-color: transparent; border-radius:50%; animation: spin 0.7s linear infinite; vertical-align: middle; margin-left:6px;
    }
    @keyframes spin { to { transform: rotate(360deg);} }
    #authForm.fade-out { opacity:0; transition: opacity 0.4s ease; }
    #authForm[hidden] { display:none !important; }
    .meta-line { font-size:12px; opacity:0.85; margin-top:4px; }
    /* Registry PATCH form layout improvements */
    .registry-patch { display:flex; flex-direction:column; gap:10px; margin-top:8px; }
    .registry-patch .row { display:flex; flex-direction:column; gap:6px; }
    .registry-patch input[type="text"], .registry-patch textarea { width:100%; padding:8px 10px; border-radius:10px; border:1px solid var(--border); background: var(--card); color: var(--text); }
    .registry-patch textarea { resize:vertical; min-height:72px; }
    /* reduce transitions in patch area to avoid layout jitter */
    .registry-patch input[type="text"], .registry-patch textarea { transition: none; }
    .registry-patch input[type="text"]:focus, .registry-patch textarea:focus { outline: none; box-shadow: 0 6px 18px rgba(11,102,195,0.04); border-color: rgba(11,102,195,0.22); }
    .registry-patch label { font-weight:600; }
    .registry-patch .checkbox-row { display:flex; align-items:center; gap:8px; }
    .registry-patch button { align-self:flex-start; margin-top:6px; }
    .inline-small { font-size:12px; }
    /* authStatus container basic styling */
    #authStatus {
      padding: 10px;
      font-weight: bold;
      border-radius: 12px;
      margin-bottom: 20px;
    }
    #authStatus.not-auth {
      background-color: #ffd6d6;
      color: #b30000;
    }
    #authStatus.auth {
      background-color: #d6ffd6;
      color: #006600;
    }
    #authStatus.rate-limited {
      background-color: #fff0d6; /* light orange */
      color: #8a4b00; /* dark orange text */
    }
    body.dark #authStatus.rate-limited {
      background-color: #553a20;
      color: #ffdca8;
    }
    /* Danger knop styling */
    .danger {
      background:#c62828;
      color:#fff;
      border:1px solid #b71c1c;
      padding:8px 14px;
      border-radius:6px;
      font-weight:600;
    }
    .danger:hover { background:#b71c1c; }
    body.dark .danger { background:#b71c1c; border-color:#8e1515; }
    body.dark .danger:hover { background:#a11919; }
    #logoutBtn, #validateBtn, #copyBtn, #darkModeBtn {
      margin-left: 10px;
      padding: 6px 12px;
    }
    #output {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid var(--border);
      background: #ffffff;
      border-radius: 12px;
      max-height: 400px;
      overflow-y: auto;
      transition: background 0.3s, border-color 0.3s;
    }
    pre {
      margin: 0;
      font-family: monospace;
      white-space: pre-wrap;
    }

  /* ---- DARK MODE ---- */
    body.dark {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    body.dark input, body.dark select, body.dark button {
      background: #2f2f2f;
      color: #e0e0e0;
      border: 1px solid #555;
    }
    body.dark button:hover {
      background:#3a3a3a;
    }
    body.dark form {
      background: #2b2b2b;
      border-color: #444;
    }
    body.dark details.panel { background:#262626; border-color:#444; }
    body.dark details.panel summary {
      background: linear-gradient(145deg,#2a2a2a,#242424);
      border-color:#333;
    }
    body.dark details.panel[open] summary {
      background: linear-gradient(145deg,#333,#2a2a2a);
    }
    body.dark form, body.dark .panel { background:#262626; border-color:#444; }
    body.dark #output { background:#1f1f1f; border-color:#444; }
    body.dark .token-masked { color:#dcdcdc; }
    body.dark .meta-line { color:#bbb; }
    body.dark #authStatus.not-auth {
      background-color: #5c2b2b;
      color: #ffaaaa;
    }
    body.dark #authStatus.auth {
      background-color: #2b5c2b;
      color: #aaffaa;
    }
    /* Dark mode adjustments for registry patch area */
    body.dark .registry-patch input[type="text"], body.dark .registry-patch textarea {
      background: #2f2f2f;
      color: #e0e0e0;
      border-color: #555;
    }
    body.dark .registry-patch .meta-line { color: #bbb; }
    @media (max-width: 700px) {
      .registry-patch button { width: 100%; }
    }
  /* authForm visibility controlled via JS (fade-out + hidden) */
  </style>
</head>
<body>

<!-- Init script moved to end of body -->

  <!-- Status always on top -->
  <div id="authStatus" class="not-auth">üî¥ Not Authorized</div>

  <!-- Title always visible -->
  <h1>
    Full Test Console 
    <button id="darkModeBtn" onclick="toggleDarkMode()" aria-label="Toggle Dark Mode">üåô Dark Mode</button>
  </h1>
  <!-- Registry Section (starts collapsed) -->
  <details class="panel" id="registrySection">
    <summary>üì¶ Registry Management <span class="badge">registry</span></summary>
    <div class="content">
      <div id="registryForms">
        <h3>Create Registry</h3>
        <label>App Name:</label>
        <input id="appName" type="text" placeholder="my_app" />
        <label>Owner Username:</label>
        <input id="registryUsername" type="text" placeholder="owner username">
        <label>Owner Email:</label>
        <input id="registryEmail" type="email" placeholder="owner email (optional)">
        <label>Owner Password:</label>
        <input id="registryPassword" type="password" placeholder="owner password">
        <label>Owner Auth Level:</label>
        <input id="registryAuthLevel" type="number" min="0" step="1" placeholder="integer auth level (optional)">
        <!-- Origin token input removed: server expects AO-Addition-Token header, not a payload field -->
        <button id="createRegistryBtn" type="button">Create Registry</button>
        <hr>
        <h3>Lookup Registry</h3>
        <label>Database ID:</label>
        <input id="lookupDbId" type="text" placeholder="db id" />
        <button id="lookupRegistryBtn" type="button">Lookup</button>
        <hr>
        <h3>Authenticate Registry</h3>
        <label>Database ID:</label>
        <input id="authDbId" type="text" placeholder="db id" />
        <label>Registry Token:</label>
        <input id="registryToken" type="text" placeholder="token" />
        <button id="authRegistryBtn" type="button">Authenticate Registry</button>
        <hr>
        <h3>Update Registry (PATCH)</h3>
        <div class="registry-patch">
          <div class="row">
            <label for="patchDbId">Database ID:</label>
            <input id="patchDbId" type="text" placeholder="db id to patch" />
          </div>
          <div class="row">
            <label for="patchAppName">App Name (optional):</label>
            <input id="patchAppName" type="text" placeholder="new app name (optional)" />
          </div>
          <div class="row">
            <label for="patchAuthScheme">User Auth Scheme (JSON string):</label>
            <div style="display:flex;gap:8px;align-items:flex-start;">
              <textarea id="patchAuthScheme" rows="4" placeholder='e.g. {"notation":"integer",...}' style="flex:1"></textarea>
              <div style="display:flex;flex-direction:column;gap:6px;">
                <select id="authSchemeExamples" class="inline-small" aria-label="Auth scheme examples" style="min-width:180px">
                  <option value="">‚Äî Select example ‚Äî</option>
                  <option value='{"central_authorization_tool":{"notation":"integer","allow_key":{"else":{"smaller_than":null,"bigger_than":"16","allow":["12"],"ban":["20"]}},"hierarchy":{"main":"bigger_than","except":["1"]}}}'>Simple (integer)</option>
                  <option value='{"central_authorization_tool":{"notation":"string","translation_key":{"user":"0","admin":"1","special":"5","someone_else":"10"},"allow_key":{"registry_get_all":{"smaller_than":"5","bigger_than":null,"allow":["5"],"ban":null},"else":{"smaller_than":null,"bigger_than":null,"allow":["someone_else"],"ban":["special"]}},"hierarchy":{"main":"smaller_than","except":["special"]}}}'>Simple (string)</option>
                  <option value='{"central_authorization_tool":{"notation":"integer","allow_key":{"else":{"smaller_than":null,"bigger_than":null,"allow":["5"],"ban":null}},"hierarchy":{"main":"advanced","advanced":{"else":{"5":{"bigger_than":"1","smaller_than":null,"allow":["2","3"],"ban":[]}}},"except":["0"]}}}'>Advanced (integer)</option>
                </select>
                <button type="button" class="inline-small" id="clearAuthScheme">Clear</button>
              </div>
            </div>
          </div>
          <div class="row">
            <label for="patchTranslation">Translation (JSON object mapping old-&gt;new; keys/values may be numbers or strings, optional):</label>
            <div style="display:flex;gap:8px;align-items:flex-start;">
              <textarea id="patchTranslation" rows="3" placeholder='e.g. {"5":"10","admin":"superadmin","3":"guest","member":"1"}' style="flex:1"></textarea>
              <div style="display:flex;flex-direction:column;gap:6px;">
                <select id="translationExamples" class="inline-small" aria-label="Translation examples" style="min-width:180px">
                  <option value="">‚Äî Select example ‚Äî</option>
                  <option value='{"5":"10","1":"2"}'>int->int</option>
                  <option value='{"guest":"visitor","admin":"superadmin"}'>str->str</option>
                  <option value='{"3":"guest","2":"member"}'>int->str</option>
                  <option value='{"member":"1","moderator":"2"}'>str->int</option>
                  <option value='{"5":"10","guest":"visitor","3":"guest","member":"1"}'>Mixed advanced</option>
                </select>
                <button type="button" class="inline-small" id="clearTranslation">Clear</button>
              </div>
            </div>
          </div>
          <div class="row checkbox-row">
            <input id="patchAuthorized" type="checkbox">
            <label for="patchAuthorized">Authorized (check to set authorized=true)</label>
          </div>
          <div class="meta-line">Note: `user_auth_scheme` is optional; if provided, give it as a JSON string. Translation should be a JSON object mapping old-&gt;new auth levels. Keys and values must be strings (quote numeric values), the server will handle coercion. Examples: int-&gt;int: {"5":"10"}, str-&gt;str: {"guest":"visitor"}, int-&gt;str: {"3":"guest"}, str-&gt;int: {"member":"1"}.</div>
          <button id="patchRegistryBtn" type="button">Patch Registry</button>
        </div>
      </div>
    </div>
  </details>

  <!-- (Removed) Global submit handler replaced by targeted listeners at end of body -->

  <!-- Authentication form (always displayed before login) -->
  <div id="authForm" data-form="auth">
    <h3>User Authentication</h3>
    <div id="demoLoginNote" class="meta-line">Demo login: <strong>Username:</strong> <code>DemoUser101</code> &nbsp; (<strong>Email:</strong> <code>DemoEmail@jvm.place</code>) &nbsp; <strong>Password:</strong> <code>1234</code> &nbsp; <strong>DB id:</strong> <code>-</code></div>
    <label>Target Database ID:</label>
  <input id="authDbIdUsers" type="text" required>

    <label>Username or Email:</label>
  <input id="usernameOrEmail" type="text" required>

    <label>Password:</label>
  <input id="authPassword" type="password" required>

    <label>Time Extension (minutes):</label>
  <input id="timeExtension" type="number" value="30" required>

    <button id="authSubmitBtn" type="button">Authenticate User</button>
  </div>

  <!-- User Section (starts collapsed) -->
  <details class="panel" id="userSection">
    <summary>üë• User Management <span class="badge">users</span></summary>
    <div class="content">
      <div id="userForm" data-form="user">
        <h3>User CRUD Operations</h3>
        <div class="field" data-field="dbId">
          <label for="dbId">Target Database ID:</label>
          <input id="dbId" type="text" required>
        </div>
        <div class="field" data-field="identifier">
          <label for="identifier">Identifier (username/email/ID):</label>
          <input id="identifier" type="text" placeholder="leave empty for list (GET)">
        </div>
        <div class="field" data-field="idMethod">
          <label for="idMethod">Identifier Method:</label>
          <select id="idMethod">
            <option value="username">Username</option>
            <option value="email">Email</option>
            <option value="id">ID (Identification Number)</option>
          </select>
        </div>
        <div class="field" data-field="username">
          <label for="username">Username:</label>
          <input id="username" type="text" autocomplete="off">
        </div>
        <div class="field" data-field="email">
          <label for="email">Email (optional):</label>
          <input id="email" type="email" autocomplete="off" placeholder="optional">
        </div>
        <div class="field" data-field="password">
          <label for="password">Password:</label>
          <input id="password" type="password" autocomplete="new-password">
        </div>
        <!-- Origin token removed: backend expects AO-Addition-Token header, not a JSON payload field -->
        <div class="field" data-field="authLevel">
          <label for="authLevel">Auth Level (integer):</label>
          <input id="authLevel" type="number" inputmode="numeric" step="1" min="0" placeholder="e.g. 0 = user, 1 = moderator, 5 = admin" list="authLevelOptions">
          <datalist id="authLevelOptions">
            <option value="0">User</option>
            <option value="1">Moderator</option>
            <option value="2">Manager</option>
            <option value="3">Support</option>
            <option value="5">Admin</option>
            <option value="10">Owner</option>
          </datalist>
        </div>
        <div class="field" data-field="requestType">
          <label for="requestType">Action:</label>
          <select id="requestType">
            <option value="GET">GET (List or Lookup)</option>
            <option value="POST">POST (Create)</option>
            <option value="PATCH">PATCH (Update)</option>
            <option value="DELETE">DELETE (Remove)</option>
          </select>
        </div>
        <div class="field" data-field="submitBtn">
          <button id="userSubmitBtn" type="button">Submit User Request</button>
        </div>
        <div class="field" data-field="selfDelete" style="display:none">
          <button id="selfDeleteBtn" type="button" class="danger">Delete My Account</button>
        </div>
      </div>
    </div>
  </details>

  <!-- Output area -->
  <h2>Response Output</h2>
  <div id="output"><pre>Responses will appear here...</pre></div>


  <!-- Load external configuration (API base URL, etc.) -->
  <script src="config.js"></script>

<script>
// ==== Config ====
// Prefer apiBase from global APP_CONFIG, fall back to default if missing
const apiBase = (window.APP_CONFIG && window.APP_CONFIG.apiBase) || "https://didactic-space-palm-tree-v6gw94rjqw6p3wp5v-5000.app.github.dev/";

// ==== Helpers ====
function formatTime(date) { return date.toLocaleString(); }
function showOutput(title, data) {
  const out = document.getElementById("output");
  if (!out) return;
  const pre = document.createElement('pre');
  const text = `${title}\n${JSON.stringify(data, null, 2)}`;
  pre.textContent = text; // render any HTML-like content as plain text
  out.innerHTML = "";
  out.appendChild(pre);
  try { localStorage.setItem('lastOutput', text); } catch(e) { /* ignore storage errors */ }
}
// Basic HTML-escaping helper for any dynamic text that must go into innerHTML
function escapeHtml(str) {
  if (str == null) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
// Add helper to auto inject auth token header expected by the API
function authFetch(url, options = {}) {
  const token = localStorage.getItem('authToken');
  options.headers = options.headers || {};
  // API expects the raw token in the `X-Auth-Token` header (server reads this).
  if (token && !options.headers['X-Auth-Token']) {
    options.headers['X-Auth-Token'] = token;
  }
  // Ensure a db_id header is sent for registry requests (or use last known db id)
  try {
      if (!options.headers['db-id']) {
      let dbId = localStorage.getItem('lastDbId') || '';
      // try to extract db id from common registry URL patterns
      const m1 = url.match(/\/api\/registry\/authenticate\/([^\/]+)\//);
      const m2 = url.match(/\/api\/registry\/([^\/]+)\//);
      if (m1 && m1[1]) dbId = m1[1];
      else if (m2 && m2[1]) dbId = m2[1];
      if (dbId) {
        options.headers['db-id'] = dbId;
      }
    }
  } catch (e) {}
  return fetch(url, options);
}

// ==== Dark Mode ====
function toggleDarkMode() {
  document.body.classList.toggle("dark");
  const enabled = document.body.classList.contains("dark");
  localStorage.setItem("darkMode", enabled ? "1" : "0");
  document.getElementById("darkModeBtn").textContent = enabled ? "‚òÄÔ∏è Light Mode" : "üåô Dark Mode";
}
function initDarkMode() {
  if (localStorage.getItem("darkMode") === "1") {
    document.body.classList.add("dark");
    document.getElementById("darkModeBtn").textContent = "‚òÄÔ∏è Light Mode";
  }
}

// ==== Auth Status ====
function maskIfNeeded(token) {
  const mask = localStorage.getItem('maskToken') === '1';
  if (!mask) return token;
  if (!token || token.length <= 8) return '‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
  return token.slice(0,4)+ '‚Ä¶' + token.slice(-4);
}

function updateAuthStatus() {
  // If currently rate-limited, show a persistent rate-limit status and hide other UI
  if (window._rateLimitUntil && Date.now() < window._rateLimitUntil) {
    const statusDiv = document.getElementById("authStatus");
    const msLeft = Math.max(0, window._rateLimitUntil - Date.now());
    const sec = Math.ceil(msLeft / 1000);
    const token = localStorage.getItem("authToken");
    const dbId = localStorage.getItem("lastDbId");
    const lastValidatedRaw = localStorage.getItem("lastValidated");
    const userId = localStorage.getItem("userId");
    const userRole = localStorage.getItem("userRole");
    const masked = maskIfNeeded(token);
    let since = '';
    let lastDisplay = '';
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (!isNaN(d.getTime())) {
        const diff = Date.now() - d.getTime();
        const sec_age = Math.floor(diff/1000);
        const m = Math.floor(sec_age/60);
        const s = sec_age%60;
        since = ` (<span id='elapsedSinceValidate'>${m}m ${s}s</span> ago)`;
        lastDisplay = formatTime(d);
      } else {
        lastDisplay = lastValidatedRaw;
      }
    }
    let html = `üü† Rate Limited`+
    `<div class='status-line'>Token: <span class='token-masked'>${escapeHtml(masked)}</span>`+
    `<span class='inline-controls'>`+
    `<button id='copyBtn' type='button' onclick='copyToken()'>üìã Copy</button>`+
    `<button id='maskToggleBtn' type='button' onclick='toggleMask()'>${localStorage.getItem('maskToken')==='1'?'üëÅÔ∏è Show':'üôà Mask'}</button>`+
    `</span></div>`+
    `<div class='status-line'>DB: ${escapeHtml(dbId || '‚Äî')} <button id='logoutBtn' type='button' onclick='logout(true)'>Logout</button>`+
    `<button id='validateBtn' type='button' disabled>Validate Token</button></div>`+
      (userId? `<br>User ID: ${escapeHtml(userId)}` : '') +
      (userRole? `<br>Role: ${escapeHtml(userRole)}` : '') +
      (lastDisplay? `<br><i>Last validated: ${lastDisplay}${since}</i>` : '') +
      `<br><b>Retry in <span id='rateLimitCountdown'>${sec}s</span></b>`;
    statusDiv.innerHTML = html;
    statusDiv.className = "rate-limited";
    // hide the main interactive sections to emphasize waiting state
    const userSection = document.getElementById("userSection");
    const registrySection = document.getElementById("registrySection");
    const af = document.getElementById("authForm");
    if (userSection) userSection.style.display = "none";
    if (registrySection) registrySection.style.display = "none";
    if (af) { af.setAttribute('hidden','hidden'); af.classList.remove('fade-out'); }
    return;
  }
  const token = localStorage.getItem("authToken");
  const dbId = localStorage.getItem("lastDbId");
  const lastValidatedRaw = localStorage.getItem("lastValidated"); // now stored as ISO
  const userId = localStorage.getItem("userId");
  const userRole = localStorage.getItem("userRole");
  const statusDiv = document.getElementById("authStatus");
  const userSection = document.getElementById("userSection");
  const registrySection = document.getElementById("registrySection");
  // debug artifacts removed earlier
  if (token && dbId) {
    const masked = maskIfNeeded(token);
    let since = '';
    let lastDisplay = '';
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (!isNaN(d.getTime())) {
        const diff = Date.now() - d.getTime();
        const sec = Math.floor(diff/1000);
        const m = Math.floor(sec/60);
        const s = sec%60;
        since = ` (<span id='elapsedSinceValidate'>${m}m ${s}s</span> ago)`;
        lastDisplay = formatTime(d);
      } else {
        // fallback: if parsing fails, show raw stored value
        lastDisplay = lastValidatedRaw;
      }
    }
    let html = `üü¢ Authorized`+
      `<div class='status-line'>Token: <span class='token-masked'>${escapeHtml(masked)}</span>`+
      `<span class='inline-controls'>`+
      `<button id='copyBtn' type='button' onclick='copyToken()'>üìã Copy</button>`+
      `<button id='maskToggleBtn' type='button' onclick='toggleMask()'>${localStorage.getItem('maskToken')==='1'?'üëÅÔ∏è Show':'üôà Mask'}</button>`+
      `</span></div>`+
      `<div class='status-line'>DB: ${escapeHtml(dbId)} <button id='logoutBtn' type='button' onclick='logout(true)'>Logout</button>`+
      `<button id='validateBtn' type='button' onclick='validateToken()'>Validate Token</button></div>`;
    if (userId) html += `<br>User ID: ${escapeHtml(userId)}`;
    if (userRole) html += `<br>Role: ${escapeHtml(userRole)}`;
    if (lastDisplay) html += `<br><i>Last validated: ${escapeHtml(lastDisplay)}${since}</i>`;
    statusDiv.innerHTML = html;
    statusDiv.className = "auth";
    autoFillDbId(dbId);
    if (userSection) { userSection.style.display = ""; }
    if (registrySection) { registrySection.style.display = ""; }
    const af = document.getElementById("authForm");
    if (af && !af.hasAttribute('hidden')) {
      af.classList.add('fade-out');
      setTimeout(()=>{ af.setAttribute('hidden','hidden'); }, 350);
    }
    updateUserFormVisibility();
  } else {
    let msg = "üî¥ Not Authorized";
  	if (window._showUnauthMsg) msg += "<br><b>You have been logged out or the session expired.</b>";
    statusDiv.innerHTML = msg;
    statusDiv.className = "not-auth";
    window._showUnauthMsg = false;
    if (userSection) userSection.style.display = "none";
    if (registrySection) registrySection.style.display = "none";
    const af = document.getElementById("authForm");
    if (af) { af.removeAttribute('hidden'); af.classList.remove('fade-out'); }
  }
}

function logout(announce) {
  ["authToken","lastDbId","lastValidated","userId","userRole"].forEach(k=>localStorage.removeItem(k));
  window._showUnauthMsg = true;
  // Force show auth form immediately
  const af = document.getElementById('authForm');
  if (af) {
    af.removeAttribute('hidden');
    af.classList.remove('fade-out');
    af.style.display = '';
  }
  // Clear any active rate-limit state so logout overrides rate-limited UI
  try { delete window._rateLimitUntil; } catch(e) { window._rateLimitUntil = 0; }
  try { delete window._rateLimitAnnounced; } catch(e) { window._rateLimitAnnounced = false; }
  // Update UI now
  updateAuthStatus();
  if (announce) showOutput("Logout", {status:"ok"});
}
function copyToken() {
  const token = localStorage.getItem("authToken");
  if (!token) return;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(token).then(showCopyHint).catch(()=>fallbackCopy(token));
  } else {
    fallbackCopy(token);
  }
}
function showCopyHint(){
  let hint = document.getElementById('copyHint');
  if (!hint) {
    hint = document.createElement('div');
    hint.id = 'copyHint';
    hint.style.position = 'fixed';
    hint.style.top = '12px';
    hint.style.right = '16px';
    hint.style.background = 'rgba(40,40,40,0.85)';
    hint.style.color = '#fff';
    hint.style.padding = '6px 12px';
    hint.style.borderRadius = '6px';
    hint.style.fontSize = '13px';
    hint.style.fontFamily = 'system-ui, Arial, sans-serif';
    hint.style.zIndex = '9999';
    hint.style.opacity = '0';
    hint.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
    hint.style.transform = 'translateY(-6px)';
    hint.textContent = 'Copied!';
    document.body.appendChild(hint);
  }
  // reset animation
  void hint.offsetWidth;
  hint.style.opacity = '1';
  hint.style.transform = 'translateY(0)';
  clearTimeout(window._copyHintTimer);
  window._copyHintTimer = setTimeout(()=>{
    hint.style.opacity='0';
    hint.style.transform='translateY(-6px)';
  }, 1600);
}
  function fallbackCopy(text){
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.top='-1000px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      showCopyHint();
    } catch(e){ console.warn('Fallback copy failed', e); }
  }
function toggleMask(){
  const cur = localStorage.getItem('maskToken')==='1';
  localStorage.setItem('maskToken', cur? '0':'1');
  updateAuthStatus();
}

// ==== Rate Limit Helper ====
function setRateLimitCooldown(res, info){
  // Accept either a Response or a numeric/string message in res
  let ms = 30000; // default 30s
  try {
    if (res) {
      // If res is a Response, try headers Retry-After first
      if (res.headers && typeof res.headers.get === 'function') {
        const ra = res.headers.get('Retry-After');
        if (ra) {
          const sec = parseInt(ra,10);
          if (!isNaN(sec)) ms = sec * 1000;
          else {
            // Retry-After can be a HTTP date ‚Äî try Date parse
            const d = Date.parse(ra);
            if (!isNaN(d)) ms = Math.max(0, d - Date.now());
          }
        }
      }
      // If info param provided and contains textual info, use it first
      let text = null;
      if (info) {
        if (typeof info === 'string') text = info;
        else if (info && info.message && typeof info.message === 'string') text = info.message;
        else if (info && info.error && typeof info.error === 'string') text = info.error;
      }
      // Otherwise, try to derive text from res
      if (!text) {
        if (typeof res === 'string') text = res;
        else if (res && res.message && typeof res.message === 'string') text = res.message;
        else if (res && res.error && typeof res.error === 'string') text = res.error;
      }
      // If no text yet and Response is cloneable, attempt to read a short text (non-blocking best-effort)
      if (!text && res && typeof res.clone === 'function') {
        try {
          // clone and read without awaiting caller (best-effort)
          res.clone().text().then(t => {
            try { parseRateTextAndSet(t); } catch(e){}
          }).catch(()=>{});
        } catch(e){}
      }
      if (text) {
        // parse patterns like '10 per 1 minute' or '2 per 1 second'
        const m = text.match(/per\s+(\d+)\s*(second|minute|hour)s?/i);
        if (m) {
          const num = parseInt(m[1],10);
          const unit = m[2].toLowerCase();
          const unitSec = unit.startsWith('second') ? 1 : unit.startsWith('minute') ? 60 : 3600;
          ms = unitSec * num * 1000;
        }
      }
    }
  } catch(e) {
    // fallback to default
    ms = 30000;
  }
  // helper used by async clone read above
  function parseRateTextAndSet(t) {
    const m = (t||'').match(/per\s+(\d+)\s*(second|minute|hour)s?/i);
    if (m) {
      const num = parseInt(m[1],10);
      const unit = m[2].toLowerCase();
      const unitSec = unit.startsWith('second') ? 1 : unit.startsWith('minute') ? 60 : 3600;
      window._rateLimitUntil = Date.now() + unitSec * num * 1000;
      window._rateLimitAnnounced = false;
    }
  }
  window._rateLimitUntil = Date.now() + ms;
  window._rateLimitAnnounced = false; // reset announcement flag
}

// ==== Auth ====
async function authenticateUser(e) {
  if (e) e.preventDefault();
  console.log("[Auth] submit start");
  const dbId = document.getElementById("authDbIdUsers").value.trim();
  const usernameOrEmail = document.getElementById("usernameOrEmail").value.trim();
  const password = document.getElementById("authPassword").value;
  const timeExtension = document.getElementById("timeExtension").value || 30;
  const statusDiv = document.getElementById("authStatus");
  try {
    // changed scheme: use 'create' instead of '0'
    const url = `${apiBase}api/${dbId}/users/authenticate/create/${timeExtension}/`;
    const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({username_or_email: usernameOrEmail, password})});
    let data = null;
    try { data = await res.json(); } catch(parseErr){ data = {error:"Invalid JSON response", detail: parseErr+""}; }
    console.log("[Auth] response", res.status, data);
    if (res.status === 429) {
      setRateLimitCooldown(res, data);
      showOutput("Rate Limit", data || {error:"Too Many Requests"});
      updateAuthStatus();
      return false; // do not logout
    }
    if (res.status === 401 || res.status === 403) {
      logout();
      throw new Error(data && data.error ? data.error : `HTTP ${res.status}`);
    }
    if (!res.ok) {
      // 500 and other errors: do not logout, just show error
      showOutput("Auth HTTP Error", data || {status:res.status});
      return false;
    }
    if (data && data.auth_token) {
      localStorage.setItem("authToken", data.auth_token);
      localStorage.setItem("lastDbId", dbId);
      // store ISO timestamp for reliable parsing
      localStorage.setItem("lastValidated", new Date().toISOString());
      if (data.user_id) localStorage.setItem("userId", data.user_id);
      if (data.auth_level) localStorage.setItem("userRole", data.auth_level);
      showOutput("User Auth", data);
      updateAuthStatus();
    } else {
  throw new Error(data && data.error ? data.error : "Unknown authentication error");
    }
  } catch(err) {
    console.warn("[Auth] error", err);
	const safeErr = escapeHtml(err+"");
	statusDiv.innerHTML = `üî¥ Not Authorized<br><b>Authentication error: ${safeErr}</b>`;
    statusDiv.className = "not-auth";
    showOutput("Auth Error", {error: err+""});
  }
  return false;
}

async function validateToken() {
  // If still rate-limited, announce and update UI
  if (window._rateLimitUntil && Date.now() < window._rateLimitUntil) {
    if (!window._rateLimitAnnounced) {
      showOutput('Rate Limit Cooldown', {until: new Date(window._rateLimitUntil).toLocaleTimeString()});
      window._rateLimitAnnounced = true;
    }
    updateAuthStatus();
    return;
  }

  const validateBtn = document.getElementById('validateBtn');
  if (validateBtn && !validateBtn.classList.contains('validate-busy')) {
    validateBtn.classList.add('validate-busy');
    const original = validateBtn.textContent;
    validateBtn.setAttribute('data-orig', original);
    validateBtn.textContent = 'Validating';
    const spinner = document.createElement('span');
    spinner.className='spinner-inline';
    validateBtn.appendChild(spinner);
  }

  const token = localStorage.getItem("authToken");
  const dbId = localStorage.getItem("lastDbId");
  if (!token || !dbId) { showOutput("Validation Error", {error:"Missing token or DB."});
    if (validateBtn) setTimeout(()=>{ validateBtn.classList.remove('validate-busy'); const sp=validateBtn.querySelector('.spinner-inline'); if (sp) sp.remove(); validateBtn.textContent = validateBtn.getAttribute('data-orig') || 'Validate Token'; }, 50);
    return; }

  // perform validation and always clear spinner/busy state afterwards
  try {
    const url = `${apiBase}api/${dbId}/users/authenticate/curr/5/`;
    const userId = localStorage.getItem("userId") || "";
    const res = await authFetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({user_id: userId})});
    let data = null; try { data = await res.json(); } catch(e){ data={error:"Invalid JSON"}; }
    if (res.status === 429) { setRateLimitCooldown(res, data); showOutput("Rate Limit", data || {error:"Too Many Requests"}); updateAuthStatus(); return; }
    if (res.status === 401 || res.status === 403) { logout(); throw new Error(data && data.error ? data.error : `HTTP ${res.status}`); }
    if (!res.ok || !data || !data.auth_token) { showOutput("Validation HTTP Error", data || {status:res.status}); return; }
    localStorage.setItem("authToken", data.auth_token);
    // store ISO timestamp for reliable parsing
    localStorage.setItem("lastValidated", new Date().toISOString());
    if (data.user_id) localStorage.setItem("userId", data.user_id);
    if (data.auth_level) localStorage.setItem("userRole", data.auth_level);
    showOutput("Token Validation", data);
    updateAuthStatus();
  } catch(err) {
    showOutput("Validation Error", {error: err+""});
  } finally {
    if (validateBtn) {
      try {
        const orig = validateBtn.getAttribute('data-orig') || 'Validate Token';
        validateBtn.textContent = orig;
        validateBtn.classList.remove('validate-busy');
        const sp = validateBtn.querySelector('.spinner-inline'); if (sp) sp.remove();
      } catch(e){}
    }
  }
}

// ==== Users CRUD ====
async function sendUserRequest(e) {
  if (e) e.preventDefault();
  console.log("[UserRequest] submit start");
  const dbId = document.getElementById("dbId").value.trim();
  const identifier = document.getElementById("identifier").value.trim();
  const idMethod = document.getElementById("idMethod").value;
  const username = document.getElementById("username").value.trim();
  const email = document.getElementById("email").value.trim();
  const password = document.getElementById("password").value;
  // originToken removed: backend does not accept a token in the JSON body
  // Replace string role with integer-only input parsing
  const authLevelRaw = document.getElementById("authLevel").value;
  const authLevelNum = authLevelRaw === '' ? null : parseInt(authLevelRaw, 10);
  if (authLevelRaw !== '' && (!Number.isFinite(authLevelNum) || !Number.isInteger(authLevelNum))) {
    return showOutput("Validation Error", {error:"Auth level must be an integer."});
  }
  const requestType = document.getElementById("requestType").value;
  const token = localStorage.getItem("authToken");
  const userId = localStorage.getItem("userId");
  // const userRole = localStorage.getItem("userRole");
  const statusDiv = document.getElementById("authStatus");
  if (!dbId) return showOutput("Validation Error", {error:"Database ID required."});
  if (requestType === 'POST') {
    if (!username) return showOutput("Validation Error", {error:"Username required (POST)."});
    if (!password) return showOutput("Validation Error", {error:"Password required (POST)."});
  }

  const base = `${apiBase}api/${dbId}/users/`;
  const headers = {"Content-Type":"application/json"};
  // Authorization now auto added by authFetch

  // Build payload dynamically
  const userData = {};
  if (requestType === 'POST') {
    userData.username = username;
    if (email) userData.email = email;
    userData.password = password;
    if (authLevelNum !== null) userData.auth_level = authLevelNum;
  } else if (requestType === 'PATCH') {
    if (!identifier) return showOutput("Validation Error", {error:"Identifier required (PATCH)."});
    if (!password) return showOutput("Validation Error", {error:"Password required (PATCH)."});
    if (username) userData.username = username;
    if (email) userData.email = email;
    userData.password = password;
    if (authLevelNum !== null) userData.auth_level = authLevelNum;
    if (Object.keys(userData).length === 0) return showOutput("Validation Error", {error:"No changes supplied."});
  }
  try {
    if (requestType === "POST") {
      const res = await authFetch(base, {method:"POST", headers, body: JSON.stringify(userData)});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) {
        let data = null;
        try { data = await res.json(); } catch(e) { try { const t = await res.clone().text(); data = {error: t}; } catch(_) { data = {error: `HTTP ${res.status}`}; } }
        showOutput("Unauthorized", data);
        logout();
        return;
      }
      const data = await res.json(); showOutput("User Created", data); resetUserForm(); return false;
    }
    if (requestType === "DELETE") {
      if (!identifier) return showOutput("Validation Error", {error:"Identifier required."});
      // Block DELETE for protected user by id, username, or email
      const protectedId = "1bed1bf829cb9036ba9a19b96ffdbc86";
      const protectedUsername = "DemoUser101";
      const protectedEmail = "DemoEmail@jvm.place";
      if (
        identifier === protectedId ||
        identifier === protectedUsername ||
        identifier === protectedEmail
      ) {
        return showOutput("DELETE Error", {error:"This user cannot be deleted."});
      }
      const res = await authFetch(base+idMethod+`/${identifier}/`, {method:"DELETE", headers});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) {
        let data = null;
        try { data = await res.json(); } catch(e) { try { const t = await res.clone().text(); data = {error: t}; } catch(_) { data = {error: `HTTP ${res.status}`}; } }
        showOutput("Unauthorized", data);
        logout();
        return;
      }
      const data = await res.json(); showOutput("User Deleted", data); resetUserForm(); return false;
    }
    if (requestType === "PATCH") {
      if (!identifier) return showOutput("Validation Error", {error:"Identifier required."});
      // Block PATCH for protected user by id, username, or email
      const protectedId = "1bed1bf829cb9036ba9a19b96ffdbc86";
      const protectedUsername = "DemoUser101";
      const protectedEmail = "DemoEmail@jvm.place";
      if (
        identifier === protectedId ||
        identifier === protectedUsername ||
        identifier === protectedEmail
      ) {
        return showOutput("PATCH Error", {error:"This user cannot be patched."});
      }
      const res = await authFetch(base+idMethod+`/${identifier}/`, {method:"PATCH", headers, body: JSON.stringify(userData)});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) {
        let data = null;
        try { data = await res.json(); } catch(e) { try { const t = await res.clone().text(); data = {error: t}; } catch(_) { data = {error: `HTTP ${res.status}`}; } }
        showOutput("Unauthorized", data);
        logout();
        return;
      }
      const data = await res.json(); showOutput("User Updated", data); resetUserForm(); return false;
    }
    if (requestType === "GET") {
      let url = base; if (identifier) url += idMethod+`/${identifier}/`;
      const res = await authFetch(url, {headers});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) {
        let data = null;
        try { data = await res.json(); } catch(e) { try { const t = await res.clone().text(); data = {error: t}; } catch(_) { data = {error: `HTTP ${res.status}`}; } }
        showOutput("Unauthorized", data);
        logout();
        return;
      }
      const data = await res.json(); showOutput("GET Result", data); return false;
    }
  } catch(err) { showOutput("User Request Error", {error: err+""}); }
  return false;
}

function resetUserForm() {
  ["username","email","password","identifier"].forEach(id=>{
    const el=document.getElementById(id);
    if (el) el.value="";
  });
}

function updateUserFormVisibility() {
  const requestTypeSelect = document.getElementById("requestType");
  if (!requestTypeSelect) return;
  const action = requestTypeSelect.value;
  const field = name => document.querySelector(`.field[data-field='${name}']`);
  const show = (name, cond) => { const el = field(name); if (el) el.style.display = cond ? '' : 'none'; };

  // Base visibility defaults
  show('dbId', true);
  show('requestType', true);
  show('submitBtn', true);
  show('identifier', false);
  show('idMethod', false);
  show('username', false);
  show('email', false);
  show('password', false);
  show('authLevel', false);
  show('selfDelete', true); // available to all; backend authorizes

  // No role-based hiding of options
  if (action === 'GET') {
    show('identifier', true);
    show('idMethod', true);
  } else if (action === 'POST') {
    show('username', true);
    show('email', true);
    show('password', true);
    show('authLevel', true);
  } else if (action === 'PATCH') {
    show('identifier', true);
    show('idMethod', true);
    show('username', true);
    show('email', true);
    show('password', true);
    show('authLevel', true);
  } else if (action === 'DELETE') {
    show('identifier', true);
    show('idMethod', true);
  }
}

// Self deletion without identifier input for non-admins
async function deleteOwnAccount(){
  // Removed frontend role gate; backend enforces
  const token = localStorage.getItem('authToken');
  const dbId = localStorage.getItem('lastDbId') || document.getElementById('dbId').value.trim();
  const userId = localStorage.getItem('userId');
  if (!token || !dbId || !userId) return showOutput('Self Delete Error', {error:'Missing token / dbId / userId'});
  if (!confirm('Are you sure you want to delete your account? This cannot be undone.')) return;
  try {
    const res = await authFetch(`${apiBase}api/${dbId}/users/id/${userId}/`, {method:'DELETE'});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    if (res.status === 401 || res.status === 403) {
      let data = null;
      try { data = await res.json(); } catch(e) { try { const t = await res.clone().text(); data = {error: t}; } catch(_) { data = {error: `HTTP ${res.status}`}; } }
      showOutput('Unauthorized', data);
      logout();
      return;
    }
    let data=null; try { data = await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Self Delete Result', data);
    if (res.ok) {
      logout();
    }
  } catch(err){ showOutput('Self Delete Error', {error: err+''}); }
}

function autoFillDbId(dbId) {
  if (!dbId) return;
  ["dbId","authDbIdUsers"].forEach(id=>{ const el=document.getElementById(id); if (el && !el.value) el.value=dbId; });
}

// legacy collapsible (no longer needed after details) placeholder
function setupCollapsibles() {}

// ==== Registry Functions ====
async function createRegistry(){
  const appName = document.getElementById('appName').value.trim();
  const ownerUsername = document.getElementById('registryUsername').value.trim();
  const ownerEmail = document.getElementById('registryEmail').value.trim();
  const ownerPassword = document.getElementById('registryPassword').value;
  const ownerAuthLevelRaw = document.getElementById('registryAuthLevel').value;
  // registryOriginToken input removed from UI; AO-Addition-Token is sent via header when needed
  if(!appName) { showOutput('Registry Create Error', {error:'App name required'}); return; }
  if(!ownerUsername || !ownerPassword) {
    showOutput('Registry Create Error', {error:'Owner username and password required'});
    return;
  }
  const payload = {
    app_name: appName,
    username: ownerUsername,
    password: ownerPassword
  };
  if(ownerEmail) payload.email = ownerEmail;
  if(ownerAuthLevelRaw !== '') {
    const lvl = parseInt(ownerAuthLevelRaw, 10);
    if(Number.isInteger(lvl)) payload.auth_level = lvl;
    else return showOutput('Registry Create Error', {error:'Owner auth level must be an integer'});
  }
  try {
    const headers = {'Content-Type':'application/json'};
    const lastDb = localStorage.getItem('lastDbId');
    if (lastDb) headers['db-id'] = lastDb;
    const res = await authFetch(`${apiBase}api/registry/`, {method:'POST', headers, body: JSON.stringify(payload)});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Created', data);
    if(res.ok && data && data.database_id){
      localStorage.setItem('lastDbId', data.database_id);
      autoFillDbId(data.database_id);
      updateAuthStatus();
      ['appName','registryUsername','registryEmail','registryPassword','registryAuthLevel'].forEach(id=>{
        const el=document.getElementById(id); if(el) el.value='';
      });
    }
  } catch(err){ showOutput('Registry Create Error', {error: err+''}); }
}
async function lookupRegistry(){
  const id = document.getElementById('lookupDbId').value.trim();
  if(!id){ showOutput('Registry Lookup Error', {error:'Database ID required'}); return; }
  try {
    const headers = {};
    // use the DB the user is logged into when available, otherwise fall back to the looked-up id
    const lastDb = localStorage.getItem('lastDbId');
    headers['db-id'] = lastDb || id;
    const res = await authFetch(`${apiBase}api/registry/${id}/`, {method:'GET', headers});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Lookup', data);
  } catch(err){ showOutput('Registry Lookup Error', {error: err+''}); }
}
async function authenticateRegistry(){
  const dbId = document.getElementById('authDbId').value.trim();
  const tokenPlain = document.getElementById('registryToken').value.trim();
  if(!dbId || !tokenPlain){ showOutput('Registry Auth Error', {error:'DB id and token both required'}); return; }
  try {
    // The backend expects the AO addition token in the `AO-Addition-Token` header
    // and the route requires a 'method' segment. We use 'token' as the method.
    const res = await authFetch(`${apiBase}api/registry/authenticate/${dbId}/token/`, {method:'GET', headers: {'AO-Addition-Token': tokenPlain}});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Auth', data);
  } catch(err){ showOutput('Registry Auth Error', {error: err+''}); }
}

async function patchRegistry(){
  const dbId = document.getElementById('patchDbId').value.trim();
  if(!dbId) return showOutput('Registry Patch Error', {error:'Database ID required.'});
  const appName = document.getElementById('patchAppName').value.trim();
  const authSchemeRaw = document.getElementById('patchAuthScheme').value.trim();
  const translationRaw = document.getElementById('patchTranslation').value.trim();
  const authorized = document.getElementById('patchAuthorized').checked;
  const payload = {};
  if(appName) payload.app_name = appName;
  if(authSchemeRaw) {
    // send as string (server expects a string arg for user_auth_scheme)
    payload.user_auth_scheme = authSchemeRaw;
  }
  if(translationRaw) {
    // send translation as a JSON string; backend will attempt to parse it
    try {
      // allow user to enter either object or string; normalize to JSON string
      const parsed = JSON.parse(translationRaw);
      payload.translation = JSON.stringify(parsed);
    } catch(e) {
      // if not valid JSON, send raw input (server may accept)
      payload.translation = translationRaw;
    }
  }
  // Only include authorized when checkbox is meaningful; send boolean
  payload.authorized = authorized;

  try {
    const headers = {'Content-Type':'application/json'};
    // Ensure db-id header is provided (authFetch auto-injects based on URL when possible)
    const res = await authFetch(`${apiBase}api/registry/${dbId}/`, {method:'PATCH', headers, body: JSON.stringify(payload)});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); updateAuthStatus(); return; }
    if (res.status === 401 || res.status === 403) {
      let data = null;
      try { data = await res.json(); } catch(e) { try { const t = await res.clone().text(); data = {error: t}; } catch(_) { data = {error: `HTTP ${res.status}`}; } }
      showOutput('Unauthorized', data);
      logout();
      return;
    }
    let data = null; try { data = await res.json(); } catch(e){ data = {error:'Invalid JSON'}; }
    showOutput('Registry Patch Result', data);
  } catch(err) { showOutput('Registry Patch Error', {error: err+''}); }
}

function applyAuthSchemeExample(){
  const sel = document.getElementById('authSchemeExamples');
  if (!sel) return;
  const v = sel.value;
  if (!v) return;
  try {
    const parsed = JSON.parse(v);
    document.getElementById('patchAuthScheme').value = JSON.stringify(parsed, null, 2);
  } catch(e) {
    document.getElementById('patchAuthScheme').value = v;
  }
}
function applyTranslationExample(){
  const sel = document.getElementById('translationExamples');
  if (!sel) return;
  const v = sel.value;
  if (!v) return;
  try {
    const parsed = JSON.parse(v);
    document.getElementById('patchTranslation').value = JSON.stringify(parsed, null, 2);
  } catch(e) {
    document.getElementById('patchTranslation').value = v;
  }
}
function clearAuthScheme(){ document.getElementById('patchAuthScheme').value = ''; }
function clearTranslation(){ document.getElementById('patchTranslation').value = ''; }

// ==== Init ====

// ==== Soft Auto Refresh ====
function scheduleSoftRefresh(){
  // Runs every minute: if token older than threshold or >4min since last validation, revalidate; else refresh UI
  if (window._softRefreshTimer) clearInterval(window._softRefreshTimer);
  // We now convert to a per-second engine for both countdown and elapsed update.
  window._softRefreshTimer = setInterval(()=>{
    const token = localStorage.getItem('authToken');
    const lastValidatedRaw = localStorage.getItem('lastValidated');
    if (!token) return; // nothing to do
    // If a rate-limit cooldown exists and has expired, clear it and update UI
    if (window._rateLimitUntil) {
      const msLeftCheck = window._rateLimitUntil - Date.now();
      if (msLeftCheck <= 0) {
        try { delete window._rateLimitUntil; } catch(e){ window._rateLimitUntil = 0; }
        try { delete window._rateLimitAnnounced; } catch(e){ window._rateLimitAnnounced = false; }
        updateAuthStatus();
        // continue normal loop after clearing
      } else {
        // Still rate-limited: update the rate-limited UI and countdown
        updateAuthStatus();
        if (lastValidatedRaw) {
          const d = new Date(lastValidatedRaw);
          if (!isNaN(d.getTime())) {
            const ageMs = Date.now() - d.getTime();
            const sec = Math.floor(ageMs/1000);
            const m = Math.floor(sec/60);
            const s = sec%60;
            const elapsedSpan = document.getElementById('elapsedSinceValidate');
            if (elapsedSpan) elapsedSpan.textContent = `${m}m ${s}s`;
          }
        }
        const msLeft = Math.max(0, window._rateLimitUntil - Date.now());
        const secLeft = Math.ceil(msLeft/1000);
        const rl = document.getElementById('rateLimitCountdown'); if (rl) rl.textContent = `${secLeft}s`;
        return;
      }
    }
    let needRevalidate = false;
    let nextCountdown = '--';
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (!isNaN(d.getTime())) {
        const ageMs = Date.now() - d.getTime();
        const threshold = 4 * 60 * 1000; // 4 minutes
        const remaining = threshold - ageMs;
        if (remaining <= 0) {
          needRevalidate = true;
        } else {
          const rSec = Math.max(0, Math.floor(remaining/1000));
          const m = Math.floor(rSec/60);
          const s = rSec % 60;
          nextCountdown = `${m}m ${s}s`;
        }
        // update elapsedSinceValidate span if exists
        const elapsedSpan = document.getElementById('elapsedSinceValidate');
        if (elapsedSpan) {
          const sec = Math.floor(ageMs/1000);
          const m = Math.floor(sec/60);
          const s = sec%60;
          elapsedSpan.textContent = `${m}m ${s}s`;
        }
        const nextSpan = document.getElementById('nextValidationCountdown');
        if (nextSpan) nextSpan.textContent = nextCountdown;
      } else {
        needRevalidate = true; // unparseable -> force revalidate
      }
    } else {
      needRevalidate = true; // no timestamp yet
    }
    if (needRevalidate) {
      // Only auto-validate if there has been user activity since the last validation
      try {
        const lastActivity = window._lastActivity || 0;
        const lastValidatedTime = lastValidatedRaw ? new Date(lastValidatedRaw).getTime() : 0;
        // If we have never seen activity or there has been no activity since last validation, delay the check
        if (!lastActivity || (lastValidatedTime && lastActivity <= lastValidatedTime)) {
          return;
        }
      } catch (e) {}
      validateToken();
    }
  }, 1000);
}

window.addEventListener("DOMContentLoaded", ()=>{
  setupCollapsibles(); // noop
  initDarkMode();
  // restore last output (helps keep logs after refreshes)
  try {
    const last = localStorage.getItem('lastOutput');
    if (last) {
    const out = document.getElementById('output');
    if (out) {
      const pre = document.createElement('pre');
      pre.textContent = last; // treat stored output as plain text
      out.innerHTML = '';
      out.appendChild(pre);
    }
    }
  } catch(e) {}
  // Directly show sections if a token already exists on reload
  if (localStorage.getItem('authToken') && localStorage.getItem('lastDbId')) {
    const us = document.getElementById('userSection'); if (us) { us.style.display=''; }
    const rf = document.getElementById('registrySection'); if (rf) { rf.style.display=''; }
    const af = document.getElementById('authForm');
    if (af) af.style.display='none';
  }
  updateAuthStatus();
  const authBtn = document.getElementById('authSubmitBtn');
  const userBtn = document.getElementById('userSubmitBtn');
  const regCreate = document.getElementById('createRegistryBtn');
  const regLookup = document.getElementById('lookupRegistryBtn');
  const regAuth = document.getElementById('authRegistryBtn');
  const regPatch = document.getElementById('patchRegistryBtn');
  if (authBtn) authBtn.addEventListener('click', authenticateUser);
  if (userBtn) userBtn.addEventListener('click', sendUserRequest);
  if (regCreate) regCreate.addEventListener('click', createRegistry);
  if (regLookup) regLookup.addEventListener('click', lookupRegistry);
  if (regAuth) regAuth.addEventListener('click', authenticateRegistry);
  if (regPatch) regPatch.addEventListener('click', patchRegistry);
  const authSelect = document.getElementById('authSchemeExamples');
  const transSelect = document.getElementById('translationExamples');
  const clearAuthBtn = document.getElementById('clearAuthScheme');
  const clearTransBtn = document.getElementById('clearTranslation');
  if (authSelect) authSelect.addEventListener('change', applyAuthSchemeExample);
  if (transSelect) transSelect.addEventListener('change', applyTranslationExample);
  if (clearAuthBtn) clearAuthBtn.addEventListener('click', clearAuthScheme);
  if (clearTransBtn) clearTransBtn.addEventListener('click', clearTranslation);
  const select = document.getElementById("requestType");
  if (select) { select.addEventListener("change", updateUserFormVisibility); updateUserFormVisibility(); }
  const selfDel = document.getElementById('selfDeleteBtn');
  if (selfDel) selfDel.addEventListener('click', deleteOwnAccount);
  const ident = document.getElementById('identifier');
  if (ident) ident.addEventListener('input', ()=>{
    if (document.getElementById('requestType').value === 'GET') updateUserFormVisibility();
  });
  // track basic user activity for idle-aware soft refresh
  try {
    window._lastActivity = Date.now();
    ['mousemove','keydown','click','scroll','touchstart','touchmove'].forEach(ev=>{
      window.addEventListener(ev, ()=>{ window._lastActivity = Date.now(); }, {passive:true});
    });
  } catch(e){}
  // Prevent any <form> default submits from reloading the page
  window.addEventListener('submit', function(e){ e.preventDefault(); });
  // Auto validate token after 5 minutes (initial check)
  const token = localStorage.getItem("authToken");
  const lastValidatedRaw = localStorage.getItem("lastValidated");
  if (token) {
    let shouldValidate = false;
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (isNaN(d.getTime())) shouldValidate = true;
      else if (Date.now() - d.getTime() > 300000) shouldValidate = true;
    } else shouldValidate = true;
    if (shouldValidate) validateToken();
  }
  scheduleSoftRefresh();
  // init done
});
</script>

</body>
</html>
