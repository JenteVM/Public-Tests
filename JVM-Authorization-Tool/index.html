<!--
  NOTE: This file was fully generated by AI (ChatGPT).
  For testing purposes only.
  Adjusted: token masking, improved panels, copy feedback, soft auto-refresh.
-->

<!DOCTYPE html>
<html>
<head>
  <title>Full Test Console</title>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      line-height: 1.5;
      background-color: #ffffff;
      color: #000000;
      transition: background 0.3s, color 0.3s;
    }
    form, .panel {
      border: 1px solid #ddd;
      padding: 14px 16px;
      margin-bottom: 20px;
      border-radius: 10px;
      background: #f9f9f9;
      transition: background 0.3s, border-color 0.3s, box-shadow 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    label {
      font-weight: bold;
    }
    input, select {
      margin-bottom: 10px;
      width: 100%;
      padding: 6px;
    }
    button {
      cursor: pointer;
    }
    .section {
      margin-bottom: 25px;
    }
  /* userSection visibility controlled via JS; no default display block */
    details.panel {
      background: #f9f9f9;
      padding: 0;
      overflow: hidden;
    }
    details.panel summary {
      list-style: none;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 12px 16px;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(145deg,#fcfcfc,#f0f0f0);
      border-bottom: 1px solid #e2e2e2;
    }
    details.panel[open] summary {
      background: linear-gradient(145deg,#f3f3f3,#e7e7e7);
    }
    details.panel summary::-webkit-details-marker { display:none; }
    details.panel .content { padding: 16px 16px 10px; }
    details.panel .content h3:first-child { margin-top:0; }
    .badge {
      display:inline-block; padding:2px 8px; border-radius:20px; font-size:11px; background:#ddd; font-weight:600;
    }
    body.dark .badge { background:#444; }
    .token-masked { font-family: monospace; letter-spacing: 1px; }
    .inline-controls button { margin-left:6px; }
    .status-line { line-height:1.3; }
    /* Details open/close animation */
    details.panel .content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.45s ease;
    }
    details.panel[open] .content {
      max-height: 1200px; /* sufficiently large for content */
    }
    .validate-busy {
      opacity: 0.6;
      pointer-events: none;
    }
    .spinner-inline {
      display:inline-block; width:14px; height:14px; border:2px solid #999; border-top-color: transparent; border-radius:50%; animation: spin 0.7s linear infinite; vertical-align: middle; margin-left:6px;
    }
    @keyframes spin { to { transform: rotate(360deg);} }
    #authForm.fade-out { opacity:0; transition: opacity 0.4s ease; }
    #authForm[hidden] { display:none !important; }
    .meta-line { font-size:12px; opacity:0.85; margin-top:4px; }
    .inline-small { font-size:12px; }
    /* authStatus container basic styling */
    #authStatus {
      padding: 10px;
      font-weight: bold;
      border-radius: 6px;
      margin-bottom: 20px;
    }
    #authStatus.not-auth {
      background-color: #ffd6d6;
      color: #b30000;
    }
    #authStatus.auth {
      background-color: #d6ffd6;
      color: #006600;
    }
    /* Danger knop styling */
    .danger {
      background:#c62828;
      color:#fff;
      border:1px solid #b71c1c;
      padding:8px 14px;
      border-radius:6px;
      font-weight:600;
    }
    .danger:hover { background:#b71c1c; }
    body.dark .danger { background:#b71c1c; border-color:#8e1515; }
    body.dark .danger:hover { background:#a11919; }
    #logoutBtn, #validateBtn, #copyBtn, #darkModeBtn {
      margin-left: 10px;
      padding: 5px 10px;
    }
    #output {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ddd;
      background: #fafafa;
      border-radius: 6px;
      max-height: 400px;
      overflow-y: auto;
      transition: background 0.3s, border-color 0.3s;
    }
    pre {
      margin: 0;
      font-family: monospace;
      white-space: pre-wrap;
    }

  /* ---- DARK MODE ---- */
    body.dark {
      background-color: #1e1e1e;
      color: #e0e0e0;
    }
    body.dark input, body.dark select, body.dark button {
      background: #2f2f2f;
      color: #e0e0e0;
      border: 1px solid #555;
    }
    body.dark button:hover {
      background:#3a3a3a;
    }
    body.dark form {
      background: #2b2b2b;
      border-color: #444;
    }
    body.dark details.panel { background:#262626; border-color:#444; }
    body.dark details.panel summary {
      background: linear-gradient(145deg,#2a2a2a,#242424);
      border-color:#333;
    }
    body.dark details.panel[open] summary {
      background: linear-gradient(145deg,#333,#2a2a2a);
    }
    body.dark form, body.dark .panel { background:#262626; border-color:#444; }
    body.dark #output { background:#1f1f1f; border-color:#444; }
    body.dark .token-masked { color:#dcdcdc; }
    body.dark .meta-line { color:#bbb; }
    body.dark #authStatus.not-auth {
      background-color: #5c2b2b;
      color: #ffaaaa;
    }
    body.dark #authStatus.auth {
      background-color: #2b5c2b;
      color: #aaffaa;
    }
  /* authForm visibility controlled via JS (fade-out + hidden) */
  </style>
</head>
<body>

<!-- Init script moved to end of body -->

  <!-- Status always on top -->
  <div id="authStatus" class="not-auth">🔴 Not Authorized</div>

  <!-- Title always visible -->
  <h1>
    Full Test Console 
    <button id="darkModeBtn" onclick="toggleDarkMode()" aria-label="Toggle Dark Mode">🌙 Dark Mode</button>
  </h1>
  <!-- Registry Section (starts collapsed) -->
  <details class="panel" id="registrySection">
    <summary>📦 Registry Management <span class="badge">registry</span></summary>
    <div class="content">
      <div id="registryForms">
        <h3>Create Registry</h3>
        <label>App Name:</label>
        <input id="appName" type="text" placeholder="my_app" />
        <button id="createRegistryBtn" type="button">Create Registry</button>
        <hr>
        <h3>Lookup Registry</h3>
        <label>Database ID:</label>
        <input id="lookupDbId" type="text" placeholder="db id" />
        <button id="lookupRegistryBtn" type="button">Lookup</button>
        <hr>
        <h3>Authenticate Registry</h3>
        <label>Database ID:</label>
        <input id="authDbId" type="text" placeholder="db id" />
        <label>Registry Token:</label>
        <input id="registryToken" type="text" placeholder="token" />
        <button id="authRegistryBtn" type="button">Authenticate Registry</button>
      </div>
    </div>
  </details>

  <!-- (Removed) Global submit handler replaced by targeted listeners at end of body -->

  <!-- Authentication form (always displayed before login) -->
  <div id="authForm" data-form="auth">
    <h3>User Authentication</h3>
    <div id="demoLoginNote" class="meta-line">Demo login: <strong>Username:</strong> <code>DemoUser101</code> &nbsp; (<strong>Email:</strong> <code>DemoEmail@jvm.place</code>) &nbsp; <strong>Password:</strong> <code>1234</code> &nbsp; <strong>DB id:</strong> <code>Y4L_-KPk_ho</code></div>
    <label>Target Database ID:</label>
  <input id="authDbIdUsers" type="text" required>

    <label>Username or Email:</label>
  <input id="usernameOrEmail" type="text" required>

    <label>Password:</label>
  <input id="authPassword" type="password" required>

    <label>Time Extension (minutes):</label>
  <input id="timeExtension" type="number" value="30" required>

    <button id="authSubmitBtn" type="button">Authenticate User</button>
  </div>

  <!-- User Section (starts collapsed) -->
  <details class="panel" id="userSection">
    <summary>👥 User Management <span class="badge">users</span></summary>
    <div class="content">
      <div id="userForm" data-form="user">
        <h3>User CRUD Operations</h3>
        <div class="field" data-field="dbId">
          <label for="dbId">Target Database ID:</label>
          <input id="dbId" type="text" required>
        </div>
        <div class="field" data-field="identifier">
          <label for="identifier">Identifier (username/email/ID):</label>
          <input id="identifier" type="text" placeholder="leave empty for list (GET)">
        </div>
        <div class="field" data-field="idMethod">
          <label for="idMethod">Identifier Method:</label>
          <select id="idMethod">
            <option value="username">Username</option>
            <option value="email">Email</option>
            <option value="id">ID (Identification Number)</option>
          </select>
        </div>
        <div class="field" data-field="username">
          <label for="username">Username:</label>
          <input id="username" type="text" autocomplete="off">
        </div>
        <div class="field" data-field="email">
          <label for="email">Email (optional):</label>
          <input id="email" type="email" autocomplete="off" placeholder="optional">
        </div>
        <div class="field" data-field="password">
          <label for="password">Password:</label>
          <input id="password" type="password" autocomplete="new-password">
        </div>
        <div class="field" data-field="authLevel">
          <label for="authLevel">Auth Level:</label>
          <select id="authLevel">
            <option value="user">User</option>
            <option value="admin">Admin</option>
          </select>
        </div>
        <div class="field" data-field="requestType">
          <label for="requestType">Action:</label>
          <select id="requestType">
            <option value="GET">GET (List or Lookup)</option>
            <option value="POST">POST (Create)</option>
            <option value="PATCH">PATCH (Update)</option>
            <option value="DELETE">DELETE (Remove)</option>
          </select>
        </div>
        <div class="field" data-field="submitBtn">
          <button id="userSubmitBtn" type="button">Submit User Request</button>
        </div>
        <div class="field" data-field="selfDelete" style="display:none">
          <button id="selfDeleteBtn" type="button" class="danger">Delete My Account</button>
        </div>
      </div>
    </div>
  </details>

  <!-- Output area -->
  <h2>Response Output</h2>
  <div id="output"><pre>Responses will appear here...</pre></div>



<script>
// ==== Config ====
const apiBase = "https://auth.jvm.hackclub.app/"; // change if needed

// ==== Helpers ====
function formatTime(date) { return date.toLocaleString(); }
function showOutput(title, data) {
  const out = document.getElementById("output");
  out.innerHTML = `<pre>${title}\n${JSON.stringify(data, null, 2)}</pre>`;
}

// ==== Dark Mode ====
function toggleDarkMode() {
  document.body.classList.toggle("dark");
  const enabled = document.body.classList.contains("dark");
  localStorage.setItem("darkMode", enabled ? "1" : "0");
  document.getElementById("darkModeBtn").textContent = enabled ? "☀️ Light Mode" : "🌙 Dark Mode";
}
function initDarkMode() {
  if (localStorage.getItem("darkMode") === "1") {
    document.body.classList.add("dark");
    document.getElementById("darkModeBtn").textContent = "☀️ Light Mode";
  }
}

// ==== Auth Status ====
function maskIfNeeded(token) {
  const mask = localStorage.getItem('maskToken') === '1';
  if (!mask) return token;
  if (!token || token.length <= 8) return '••••';
  return token.slice(0,4)+ '…' + token.slice(-4);
}

function updateAuthStatus() {
  const token = localStorage.getItem("authToken");
  const dbId = localStorage.getItem("lastDbId");
  const lastValidated = localStorage.getItem("lastValidated");
  const userId = localStorage.getItem("userId");
  const userRole = localStorage.getItem("userRole");
  const statusDiv = document.getElementById("authStatus");
  const userSection = document.getElementById("userSection");
  const registrySection = document.getElementById("registrySection");
  // debug artifacts removed earlier
  if (token && dbId) {
    const masked = maskIfNeeded(token);
    let since = '';
    if (lastValidated) {
      const diff = Date.now() - new Date(lastValidated).getTime();
      if (!isNaN(diff)) {
        const sec = Math.floor(diff/1000);
        const m = Math.floor(sec/60);
        const s = sec%60;
        since = ` (<span id='elapsedSinceValidate'>${m}m ${s}s</span> ago)`;
      }
    }
    let html = `🟢 Authorized`+
      `<div class='status-line'>Token: <span class='token-masked'>${masked}</span>`+
      `<span class='inline-controls'>`+
      `<button id='copyBtn' type='button' onclick='copyToken()'>📋 Copy</button>`+
      `<button id='maskToggleBtn' type='button' onclick='toggleMask()'>${localStorage.getItem('maskToken')==='1'?'👁️ Show':'🙈 Mask'}</button>`+
      `</span></div>`+
      `<div class='status-line'>DB: ${dbId} <button id='logoutBtn' type='button' onclick='logout()'>Logout</button>`+
      `<button id='validateBtn' type='button' onclick='validateToken()'>Validate Token</button></div>`;
    if (userId) html += `<br>User ID: ${userId}`;
    if (userRole) html += `<br>Role: ${userRole}`;
  if (lastValidated) html += `<br><i>Last validated: ${lastValidated}${since}</i>`;
    statusDiv.innerHTML = html;
    statusDiv.className = "auth";
    autoFillDbId(dbId);
    if (userSection) { userSection.style.display = ""; }
    if (registrySection) { registrySection.style.display = ""; }
    const af = document.getElementById("authForm");
    if (af && !af.hasAttribute('hidden')) {
      af.classList.add('fade-out');
      setTimeout(()=>{ af.setAttribute('hidden','hidden'); }, 350);
    }
    updateUserFormVisibility();
  } else {
    let msg = "🔴 Not Authorized";
  if (window._showUnauthMsg) msg += "<br><b>You have been logged out or the session expired.</b>";
    statusDiv.innerHTML = msg;
    statusDiv.className = "not-auth";
    window._showUnauthMsg = false;
    if (userSection) userSection.style.display = "none";
    if (registrySection) registrySection.style.display = "none";
    const af = document.getElementById("authForm");
    if (af) { af.removeAttribute('hidden'); af.classList.remove('fade-out'); }
  }
}

function logout() {
  ["authToken","lastDbId","lastValidated","userId","userRole"].forEach(k=>localStorage.removeItem(k));
  window._showUnauthMsg = true;
  // Force show auth form immediately
  const af = document.getElementById('authForm');
  if (af) {
    af.removeAttribute('hidden');
    af.classList.remove('fade-out');
    af.style.display = '';
  }
  updateAuthStatus();
  showOutput("Logout", {status:"ok"});
}
function copyToken() {
  const token = localStorage.getItem("authToken");
  if (!token) return;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(token).then(showCopyHint).catch(()=>fallbackCopy(token));
  } else {
    fallbackCopy(token);
  }
}
function showCopyHint(){
  let hint = document.getElementById('copyHint');
  if (!hint) {
    hint = document.createElement('div');
    hint.id = 'copyHint';
    hint.style.position = 'fixed';
    hint.style.top = '12px';
    hint.style.right = '16px';
    hint.style.background = 'rgba(40,40,40,0.85)';
    hint.style.color = '#fff';
    hint.style.padding = '6px 12px';
    hint.style.borderRadius = '6px';
    hint.style.fontSize = '13px';
    hint.style.fontFamily = 'system-ui, Arial, sans-serif';
    hint.style.zIndex = '9999';
    hint.style.opacity = '0';
    hint.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
    hint.style.transform = 'translateY(-6px)';
    hint.textContent = 'Copied!';
    document.body.appendChild(hint);
  }
  // reset animation
  void hint.offsetWidth;
  hint.style.opacity = '1';
  hint.style.transform = 'translateY(0)';
  clearTimeout(window._copyHintTimer);
  window._copyHintTimer = setTimeout(()=>{
    hint.style.opacity='0';
    hint.style.transform='translateY(-6px)';
  }, 1600);
}
  function fallbackCopy(text){
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.top='-1000px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      showCopyHint();
    } catch(e){ console.warn('Fallback copy failed', e); }
  }
function toggleMask(){
  const cur = localStorage.getItem('maskToken')==='1';
  localStorage.setItem('maskToken', cur? '0':'1');
  updateAuthStatus();
}

// ==== Rate Limit Helper ====
function setRateLimitCooldown(res){
  let ms = 30000; // default 30s
  if (res && res.headers) {
    const ra = res.headers.get('Retry-After');
    if (ra) {
      const sec = parseInt(ra,10);
      if (!isNaN(sec)) ms = sec * 1000;
    }
  }
  window._rateLimitUntil = Date.now() + ms;
  window._rateLimitAnnounced = false; // reset announcement flag
}

// ==== Auth ====
async function authenticateUser(e) {
  if (e) e.preventDefault();
  console.log("[Auth] submit start");
  const dbId = document.getElementById("authDbIdUsers").value.trim();
  const usernameOrEmail = document.getElementById("usernameOrEmail").value.trim();
  const password = document.getElementById("authPassword").value;
  const timeExtension = document.getElementById("timeExtension").value || 30;
  const statusDiv = document.getElementById("authStatus");
  try {
    const url = `${apiBase}api/${dbId}/users/authenticate/${timeExtension}/0/`;
    const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({username_or_email: usernameOrEmail, password})});
    let data = null;
    try { data = await res.json(); } catch(parseErr){ data = {error:"Invalid JSON response", detail: parseErr+""}; }
    console.log("[Auth] response", res.status, data);
    if (res.status === 429) {
      showOutput("Rate Limit", data || {error:"Too Many Requests"});
      statusDiv.innerHTML = `🟠 Rate Limited<br><b>Please wait and try again.</b>`;
      statusDiv.className = "not-auth";
      return false; // do not logout
    }
    if (res.status === 401 || res.status === 403) {
      logout();
      throw new Error(data && data.error ? data.error : `HTTP ${res.status}`);
    }
    if (!res.ok) {
      // 500 and other errors: do not logout, just show error
      showOutput("Auth HTTP Error", data || {status:res.status});
      return false;
    }
    if (data && data.auth_token) {
      localStorage.setItem("authToken", data.auth_token);
      localStorage.setItem("lastDbId", dbId);
      localStorage.setItem("lastValidated", formatTime(new Date()));
      if (data.user_id) localStorage.setItem("userId", data.user_id);
      if (data.auth_level) localStorage.setItem("userRole", data.auth_level);
      showOutput("User Auth", data);
      updateAuthStatus();
    } else {
  throw new Error(data && data.error ? data.error : "Unknown authentication error");
    }
  } catch(err) {
    console.warn("[Auth] error", err);
  statusDiv.innerHTML = `🔴 Not Authorized<br><b>Authentication error: ${err}</b>`;
    statusDiv.className = "not-auth";
    showOutput("Auth Error", {error: err+""});
  }
  return false;
}

async function validateToken() {
  if (window._rateLimitUntil && Date.now() < window._rateLimitUntil) {
    if (!window._rateLimitAnnounced) {
      showOutput('Rate Limit Cooldown', {until: new Date(window._rateLimitUntil).toLocaleTimeString()});
      window._rateLimitAnnounced = true;
    }
    return;
  }
  const validateBtn = document.getElementById('validateBtn');
  if (validateBtn && !validateBtn.classList.contains('validate-busy')) {
    validateBtn.classList.add('validate-busy');
    const original = validateBtn.textContent;
    validateBtn.setAttribute('data-orig', original);
    validateBtn.textContent = 'Validating';
    const spinner = document.createElement('span');
    spinner.className='spinner-inline';
    validateBtn.appendChild(spinner);
  }
  const token = localStorage.getItem("authToken");
  const dbId = localStorage.getItem("lastDbId");
  if (!token || !dbId) { showOutput("Validation Error", {error:"Missing token or DB."}); return; }
  try {
    const url = `${apiBase}api/${dbId}/users/authenticate/2/${token}/`;
    const userId = localStorage.getItem("userId") || "";
    const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({user_id: userId})});
    let data = null; try { data = await res.json(); } catch(e){ data={error:"Invalid JSON"}; }
  if (res.status === 429) { setRateLimitCooldown(res); showOutput("Rate Limit", data || {error:"Too Many Requests"}); return; }
  if (res.status === 401 || res.status === 403) { logout(); throw new Error(data && data.error ? data.error : `HTTP ${res.status}`); }
  if (!res.ok || !data || !data.auth_token) { showOutput("Validation HTTP Error", data || {status:res.status}); return; }
    localStorage.setItem("authToken", data.auth_token);
    localStorage.setItem("lastValidated", formatTime(new Date()));
    if (data.user_id) localStorage.setItem("userId", data.user_id);
    if (data.auth_level) localStorage.setItem("userRole", data.auth_level);
    showOutput("Token Validation", data);
    updateAuthStatus();
  } catch(err) {
  showOutput("Validation Error", {error: err+""});
  }
  if (validateBtn && validateBtn.classList.contains('validate-busy')) {
    // Restore state (delayed a tick so DOM updates first)
    setTimeout(()=>{
      const orig = validateBtn.getAttribute('data-orig') || 'Validate Token';
      validateBtn.textContent = orig;
      validateBtn.classList.remove('validate-busy');
    }, 50);
  }
}

// ==== Users CRUD ====
async function sendUserRequest(e) {
  if (e) e.preventDefault();
  console.log("[UserRequest] submit start");
  const dbId = document.getElementById("dbId").value.trim();
  const identifier = document.getElementById("identifier").value.trim();
  const idMethod = document.getElementById("idMethod").value;
  const username = document.getElementById("username").value.trim();
  const email = document.getElementById("email").value.trim();
  const password = document.getElementById("password").value;
  const authLevel = document.getElementById("authLevel").value;
  const requestType = document.getElementById("requestType").value;
  const token = localStorage.getItem("authToken");
  const userId = localStorage.getItem("userId");
  const userRole = localStorage.getItem("userRole");
  if (!dbId) return showOutput("Validation Error", {error:"Database ID required."});
  if (requestType === 'POST') {
    if (!username) return showOutput("Validation Error", {error:"Username required (POST)."});
    if (!password) return showOutput("Validation Error", {error:"Password required (POST)."});
  }

  const base = `${apiBase}api/${dbId}/users/`;
  const headers = {"Content-Type":"application/json"};
  if (token) headers["Authorization"] = "Bearer " + token;
  // Build payload dynamically
  const userData = {};
  if (requestType === 'POST') {
    userData.username = username;
    if (email) userData.email = email; // optional
    userData.password = password;
    if (authLevel && userRole === 'admin') userData.auth_level = authLevel;
  } else if (requestType === 'PATCH') {
    // Auto self-PATCH for non-admin: ignore identifier/idMethod, always patch own userId
    if (userRole === 'admin') {
      if (!identifier) return showOutput("Validation Error", {error:"Identifier required (PATCH)."});
    } else {
      if (!userId) return showOutput("PATCH Error", {error:"Missing stored userId. Re-authenticate first."});
    }
    if (username) userData.username = username;
    if (email) userData.email = email;
    if (password) userData.password = password;
    if (authLevel && userRole === 'admin') userData.auth_level = authLevel;
    if (Object.keys(userData).length === 0) return showOutput("Validation Error", {error:"No changes supplied."});
  }
  try {
    if (requestType === "POST") {
      if (userRole !== "admin") return showOutput("POST Error", {error:"Admins only."});
      const res = await fetch(base, {method:"POST", headers, body: JSON.stringify(userData)});
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("User Created", data); resetUserForm(); return false;
    }
    if (requestType === "DELETE") {
      if (!identifier) return showOutput("Validation Error", {error:"Identifier required."});
      // Block DELETE for protected user by id, username, or email
      const protectedId = "1bed1bf829cb9036ba9a19b96ffdbc86";
      const protectedUsername = "DemoUser101";
      const protectedEmail = "DemoEmail@jvm.place";
      if (
        identifier === protectedId ||
        identifier === protectedUsername ||
        identifier === protectedEmail
      ) {
        return showOutput("DELETE Error", {error:"This user cannot be deleted."});
      }
      // Allow admins to delete themselves
      if (userRole !== "admin" && identifier !== userId) return showOutput("DELETE Error", {error:"Only own account allowed."});
      const res = await fetch(base+idMethod+`/${identifier}/`, {method:"DELETE", headers});
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("User Deleted", data); resetUserForm(); return false;
    }
    if (requestType === "PATCH") {
      let patchIdentifier = identifier;
      let patchMethod = idMethod;
      if (userRole !== 'admin') {
        // force self
        patchIdentifier = userId;
        patchMethod = 'id';
        if (!patchIdentifier) return showOutput('PATCH Error', {error:'Missing stored userId. Re-authenticate.'});
      } else {
        if (!patchIdentifier) return showOutput("Validation Error", {error:"Identifier required."});
      }
      // Block PATCH for protected user by id, username, or email
      const protectedId = "1bed1bf829cb9036ba9a19b96ffdbc86";
      const protectedUsername = "DemoUser101";
      const protectedEmail = "DemoEmail@jvm.place";
      if (
        patchIdentifier === protectedId ||
        patchIdentifier === protectedUsername ||
        patchIdentifier === protectedEmail
      ) {
        return showOutput("PATCH Error", {error:"This user cannot be patched."});
      }
      const res = await fetch(base+patchMethod+`/${patchIdentifier}/`, {method:"PATCH", headers, body: JSON.stringify(userData)});
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("User Updated", data); resetUserForm(); return false;
    }
    if (requestType === "GET") {
      let url = base; if (identifier) url += idMethod+`/${identifier}/`;
      const res = await fetch(url, {headers});
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("GET Result", data); return false;
    }
  } catch(err) { showOutput("User Request Error", {error: err+""}); }
  return false;
}

function resetUserForm() {
  ["username","email","password","identifier"].forEach(id=>{ const el=document.getElementById(id); if (el) el.value=""; });
}

function updateUserFormVisibility() {
  const userRole = localStorage.getItem("userRole");
  const requestTypeSelect = document.getElementById("requestType");
  if (!requestTypeSelect) return;
  const action = requestTypeSelect.value;
  const field = name => document.querySelector(`.field[data-field='${name}']`);
  const show = (name, cond) => { const el = field(name); if (el) el.style.display = cond ? '' : 'none'; };

  // Base visibility defaults (hide most; show DB + action + submit always)
  show('dbId', true);
  show('requestType', true);
  show('submitBtn', true);
  show('identifier', false);
  show('idMethod', false);
  show('username', false);
  show('email', false);
  show('password', false);
  show('authLevel', false);
  show('selfDelete', false);

  // Dynamically hide POST/DELETE options for non-admins
  const postOpt = requestTypeSelect.querySelector("option[value='POST']");
  const deleteOpt = requestTypeSelect.querySelector("option[value='DELETE']");
  if (userRole !== 'admin') {
    if (postOpt) postOpt.hidden = true;
  if (deleteOpt) deleteOpt.hidden = true; // separate self-delete button replaces this
    if (action === 'POST' || action === 'DELETE') {
      requestTypeSelect.value = 'GET';
    }
  // Show self-delete button for non-admin
    show('selfDelete', true);
  } else {
    if (postOpt) postOpt.hidden = false;
    if (deleteOpt) deleteOpt.hidden = false;
  }

  if (action === 'GET') {
    // List or lookup: always show identifier + method (identifier may stay empty for full list)
    show('identifier', true);
    show('idMethod', true);
  } else if (action === 'POST') {
    // Create user (admin only)
    if (userRole !== 'admin') {
      // fallback: switch back to GET if user not admin
      requestTypeSelect.value = 'GET';
      updateUserFormVisibility();
      return;
    }
    show('username', true);
    show('email', true);
    show('password', true);
    show('authLevel', true);
  } else if (action === 'PATCH') {
    // For admin: show identifier selection; for non-admin: auto self so hide
    const isAdmin = userRole === 'admin';
    show('identifier', isAdmin);
    show('idMethod', isAdmin);
  // Updatable fields (username/email/password) optional; show them empty for convenience
    show('username', true);
    show('email', true);
    show('password', true);
    if (userRole === 'admin') show('authLevel', true);
  } else if (action === 'DELETE') {
    if (userRole !== 'admin') {
      // non-admin can delete only self by identifier; still show fields
      show('identifier', true);
      show('idMethod', true);
    } else {
      show('identifier', true);
      show('idMethod', true);
    }
  }
}

// Self deletion without identifier input for non-admins
async function deleteOwnAccount(){
  const userRole = localStorage.getItem('userRole');
  if (userRole === 'admin') return showOutput('Self Delete Blocked', {error:'Admins should use standard DELETE.'});
  const token = localStorage.getItem('authToken');
  const dbId = localStorage.getItem('lastDbId') || document.getElementById('dbId').value.trim();
  const userId = localStorage.getItem('userId');
  if (!token || !dbId || !userId) return showOutput('Self Delete Error', {error:'Missing token / dbId / userId'});
  if (!confirm('Are you sure you want to delete your account? This cannot be undone.')) return;
  const headers = { 'Authorization': 'Bearer ' + token };
  try {
  const res = await fetch(`${apiBase}api/${dbId}/users/id/${userId}/`, {method:'DELETE', headers});
  if (res.status === 401 || res.status === 403) { logout(); return; }
    let data=null; try { data = await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Self Delete Result', data);
    if (res.ok) {
      logout();
    }
  } catch(err){ showOutput('Self Delete Error', {error: err+''}); }
}

function autoFillDbId(dbId) {
  if (!dbId) return;
  ["dbId","authDbIdUsers"].forEach(id=>{ const el=document.getElementById(id); if (el && !el.value) el.value=dbId; });
}

// legacy collapsible (no longer needed after details) placeholder
function setupCollapsibles() {}

// ==== Registry Functions ====
async function createRegistry(){
  const appName = document.getElementById('appName').value.trim();
  if(!appName) { showOutput('Registry Create Error', {error:'App name required'}); return; }
  try {
    const res = await fetch(`${apiBase}api/registry/`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({app_name:appName})});
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Created', data);
    if(res.ok && data && data.database_id){
      localStorage.setItem('lastDbId', data.database_id);
      autoFillDbId(data.database_id);
      updateAuthStatus();
    }
  } catch(err){ showOutput('Registry Create Error', {error: err+''}); }
}
async function lookupRegistry(){
  const id = document.getElementById('lookupDbId').value.trim();
  if(!id){ showOutput('Registry Lookup Error', {error:'Database ID required'}); return; }
  try {
    const res = await fetch(`${apiBase}api/registry/${id}/`);
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Lookup', data);
  } catch(err){ showOutput('Registry Lookup Error', {error: err+''}); }
}
async function authenticateRegistry(){
  const dbId = document.getElementById('authDbId').value.trim();
  const token = document.getElementById('registryToken').value.trim();
  if(!dbId || !token){ showOutput('Registry Auth Error', {error:'DB id and token both required'}); return; }
  try {
    const res = await fetch(`${apiBase}api/registry/authenticate/${dbId}/${token}/`);
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Auth', data);
  } catch(err){ showOutput('Registry Auth Error', {error: err+''}); }
}

// ==== Init ====

// ==== Soft Auto Refresh ====
function scheduleSoftRefresh(){
  // Runs every minute: if token older than threshold or >4min since last validation, revalidate; else refresh UI
  if (window._softRefreshTimer) clearInterval(window._softRefreshTimer);
  // We now convert to a per-second engine for both countdown and elapsed update.
  window._softRefreshTimer = setInterval(()=>{
    const token = localStorage.getItem('authToken');
    const lastValidated = localStorage.getItem('lastValidated');
    if (!token) return; // nothing to do
    // Skip revalidation and updating timer during active rate limit cooldown
    if (window._rateLimitUntil && Date.now() < window._rateLimitUntil) {
      // Still update elapsed time if possible
      const lastValidated = localStorage.getItem('lastValidated');
      if (lastValidated) {
        const last = new Date(lastValidated).getTime();
        const ageMs = Date.now() - last;
        const sec = Math.floor(ageMs/1000);
        const m = Math.floor(sec/60);
        const s = sec%60;
        const elapsedSpan = document.getElementById('elapsedSinceValidate');
        if (elapsedSpan) elapsedSpan.textContent = `${m}m ${s}s`;
      }
      return;
    }
    let needRevalidate = false;
    let nextCountdown = '--';
    if (lastValidated) {
      const last = new Date(lastValidated).getTime();
      const ageMs = Date.now() - last;
      const threshold = 4 * 60 * 1000; // 4 minutes
      const remaining = threshold - ageMs;
      if (remaining <= 0) {
        needRevalidate = true;
      } else {
        const rSec = Math.max(0, Math.floor(remaining/1000));
        const m = Math.floor(rSec/60);
        const s = rSec % 60;
        nextCountdown = `${m}m ${s}s`;
      }
      // update elapsedSinceValidate span if exists
      const elapsedSpan = document.getElementById('elapsedSinceValidate');
      if (elapsedSpan) {
        const sec = Math.floor(ageMs/1000);
        const m = Math.floor(sec/60);
        const s = sec%60;
        elapsedSpan.textContent = `${m}m ${s}s`;
      }
      const nextSpan = document.getElementById('nextValidationCountdown');
      if (nextSpan) nextSpan.textContent = nextCountdown;
    } else {
      needRevalidate = true; // no timestamp yet
    }
    if (needRevalidate) {
      validateToken();
    }
  }, 1000);
}

window.addEventListener("DOMContentLoaded", ()=>{
  setupCollapsibles(); // noop
  initDarkMode();
  // Directly show sections if a token already exists on reload
  if (localStorage.getItem('authToken') && localStorage.getItem('lastDbId')) {
    const us = document.getElementById('userSection'); if (us) { us.style.display=''; }
    const rf = document.getElementById('registrySection'); if (rf) { rf.style.display=''; }
    const af = document.getElementById('authForm');
    if (af) af.style.display='none';
  }
  updateAuthStatus();
  const authBtn = document.getElementById('authSubmitBtn');
  const userBtn = document.getElementById('userSubmitBtn');
  const regCreate = document.getElementById('createRegistryBtn');
  const regLookup = document.getElementById('lookupRegistryBtn');
  const regAuth = document.getElementById('authRegistryBtn');
  if (authBtn) authBtn.addEventListener('click', authenticateUser);
  if (userBtn) userBtn.addEventListener('click', sendUserRequest);
  if (regCreate) regCreate.addEventListener('click', createRegistry);
  if (regLookup) regLookup.addEventListener('click', lookupRegistry);
  if (regAuth) regAuth.addEventListener('click', authenticateRegistry);
  const select = document.getElementById("requestType");
  if (select) { select.addEventListener("change", updateUserFormVisibility); updateUserFormVisibility(); }
  const selfDel = document.getElementById('selfDeleteBtn');
  if (selfDel) selfDel.addEventListener('click', deleteOwnAccount);
  const ident = document.getElementById('identifier');
  if (ident) ident.addEventListener('input', ()=>{
    if (document.getElementById('requestType').value === 'GET') updateUserFormVisibility();
  });
  // Auto validate token after 5 minutes (initial check)
  const token = localStorage.getItem("authToken");
  const lastValidated = localStorage.getItem("lastValidated");
  if (token) {
    let shouldValidate = false;
    if (lastValidated) {
      const last = new Date(lastValidated).getTime();
      if (Date.now() - last > 300000) shouldValidate = true;
    } else shouldValidate = true;
    if (shouldValidate) validateToken();
  }
  scheduleSoftRefresh();
  // init done
});
</script>

</body>
</html>