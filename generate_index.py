#!/usr/bin/env python3
"""Generate the root index.html from project description.md files."""

from __future__ import annotations

from html import escape
from pathlib import Path
from typing import Dict, Tuple

ROOT = Path(__file__).resolve().parent
DEFAULT_EMOJI = "ðŸ“¦"
DEFAULT_ORDER = 9999
README_MARKER_START = "<!-- AUTO-GENERATED:PROJECTS:START -->"
README_MARKER_END = "<!-- AUTO-GENERATED:PROJECTS:END -->"

HTML_TEMPLATE = """<!doctype html>
<html lang=\"en\">
<head>
  <meta charset=\"utf-8\" />
  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />
  <meta name=\"theme-color\" content=\"#0b66c3\" />
  <link rel=\"icon\" href=\"./favicon.svg\" type=\"image/svg+xml\" />
  <title>Public Tests</title>
  <style>
        :root {{
            --bg: #f6f4f1;
            --text: #1f2328;
            --muted: #5b6168;
            --card: #ffffff;
            --accent: #0b66c3;
            --accent-hover: #094f98;
            --border: rgba(0,0,0,0.08);
            --chip: rgba(11, 102, 195, 0.1);
            --shadow: 0 20px 50px rgba(17, 24, 39, 0.12);
        }}
        * {{ box-sizing: border-box }}
        body {{
            font-family: \"Trebuchet MS\", \"Segoe UI\", Arial, sans-serif;
            margin: 0;
            padding: 36px 32px 48px;
            color: var(--text);
            background: radial-gradient(circle at top, #ffffff 0%, #f6f4f1 45%, #efe8df 100%);
            line-height: 1.55;
        }}
        header {{ margin-bottom: 20px }}
        h1 {{ margin: 0 0 8px 0; font-size: 2rem }}
        p.lead {{ margin: 0 0 20px 0; color: var(--muted) }}
        .grid {{
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            padding: 0;
            list-style: none;
            margin: 0;
        }}
        .card {{
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 18px 18px;
            border: 1px solid var(--border);
            border-radius: 18px;
            background: var(--card);
            box-shadow: var(--shadow);
        }}
        .title-row {{
            display: flex;
            align-items: center;
            gap: 10px;
        }}
        .emoji {{
            font-size: 1.35rem;
            line-height: 1;
        }}
        a.project {{
            font-weight: 700;
            color: var(--accent);
            text-decoration: none;
        }}
        a.project:hover {{ color: var(--accent-hover); text-decoration: underline }}
        .meta {{ color: var(--muted); font-size: 0.95rem }}
        footer {{ margin-top: 34px; color: var(--muted); font-size: 0.9rem }}
        code {{ background:#f1eee9; padding:2px 6px; border-radius:6px }}
        .chip {{ display:inline-block; padding:2px 8px; border-radius:999px; background:var(--chip); color: var(--accent); font-size:0.8rem }}
  </style>
</head>
<body>
  <header>
    <h1>Public Tests</h1>
    <p class=\"lead\">This page lists public test frontends included in this workspace. Click a project to open its demo console or documentation.</p>
  </header>

  <main>
    <ul class=\"grid\">
{cards}
    </ul>

    <section style=\"margin-top:18px\">
      <h3>Repository docs</h3>
      <p class=\"meta\">Project README: <a href=\"./README.md\" target=\"_blank\" rel=\"noopener\">README.md</a></p>
    </section>
  </main>

  <footer>
    <small>Auto-generated by <code>generate_index.py</code>. Run it to refresh the list.</small>
  </footer>
</body>
</html>
"""


def parse_front_matter(text: str) -> Tuple[Dict[str, str], str]:
    stripped = text.lstrip()
    if not stripped.startswith("---"):
        return {}, text

    parts = text.split("---", 2)
    if len(parts) < 3:
        return {}, text

    _, front_raw, body = parts
    front: Dict[str, str] = {}
    for line in front_raw.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if ":" not in line:
            continue
        key, value = line.split(":", 1)
        key = key.strip()
        value = value.strip()
        if (value.startswith("\"") and value.endswith("\"")) or (
            value.startswith("'") and value.endswith("'")
        ):
            value = value[1:-1]
        front[key] = value
    return front, body


def first_paragraph(body: str) -> str:
    paragraphs = []
    current = []
    for line in body.splitlines():
        if not line.strip():
            if current:
                paragraphs.append(current)
                current = []
            continue
        current.append(line.rstrip())
    if current:
        paragraphs.append(current)

    for para_lines in paragraphs:
        joined = " ".join(part.strip() for part in para_lines).strip()
        if not joined:
            continue
        if all(line.strip().startswith("#") for line in para_lines):
            continue
        return joined
    return ""


def parse_order(value: str) -> int:
    try:
        return int(value)
    except (TypeError, ValueError):
        return DEFAULT_ORDER


def is_truthy(value: str) -> bool:
    return value.strip().lower() in {"true", "1", "yes", "y", "on"}


def build_card(folder: str, title: str, emoji: str, description: str, href: str) -> str:
    return (
        "      <li class=\"card\">\n"
        "        <div class=\"title-row\">\n"
        f"          <span class=\"emoji\" aria-hidden=\"true\">{escape(emoji)}</span>\n"
        f"          <a class=\"project\" href=\"{escape(href)}\" target=\"_blank\" rel=\"noopener\">{escape(title)}</a>\n"
        "        </div>\n"
        f"        <div class=\"meta\">{escape(description)} <span class=\"chip\">folder: <code>{escape(folder)}</code></span></div>\n"
        "      </li>"
    )


def collect_projects() -> list[dict[str, str]]:
    projects = []
    for entry in sorted(ROOT.iterdir()):
        if not entry.is_dir():
            continue
        if entry.name.startswith("."):
            continue

        description_path = entry / "description.md"
        if not description_path.exists():
            continue

        text = description_path.read_text(encoding="utf-8")
        front, body = parse_front_matter(text)

        if "hidden" in front and is_truthy(front["hidden"]):
            continue

        title = front.get("title", entry.name).strip() or entry.name
        emoji = front.get("emoji", "").strip() or DEFAULT_EMOJI
        description = front.get("description", "").strip() or first_paragraph(body)
        href = front.get("href", "").strip() or f"{entry.name}/index.html"
        order = parse_order(front.get("order", str(DEFAULT_ORDER)))

        projects.append(
            {
                "folder": entry.name,
                "title": title,
                "emoji": emoji,
                "description": description,
                "href": href,
                "order": order,
            }
        )

    projects.sort(key=lambda item: (item["order"], item["title"].lower()))
    return projects


def build_readme_block(projects: list[dict[str, str]]) -> str:
    lines = [
        README_MARKER_START,
        "",
        "## Current Projects",
        "",
        "Browse the demos and docs from the root listing or jump directly below.",
        "",
        "| Emoji | Project | Description | Folder |",
        "| --- | --- | --- | --- |",
    ]
    for item in projects:
        title = item["title"].strip() or item["folder"]
        href = item["href"].strip() or f"{item['folder']}/index.html"
        description = item["description"].strip() or "-"
        emoji = item["emoji"].strip() or DEFAULT_EMOJI
        folder = item["folder"].strip()
        lines.append(
            f"| {emoji} | [{title}]({href}) | {description} | `{folder}` |"
        )
    lines.extend(["", README_MARKER_END, ""])
    return "\n".join(lines)


def update_readme(projects: list[dict[str, str]]) -> None:
    readme_path = ROOT / "README.md"
    if not readme_path.exists():
        return

    content = readme_path.read_text(encoding="utf-8")
    block = build_readme_block(projects)

    if README_MARKER_START in content and README_MARKER_END in content:
        before, _start, rest = content.partition(README_MARKER_START)
        _mid, _end, after = rest.partition(README_MARKER_END)
        updated = before.rstrip() + "\n\n" + block + after.lstrip()
    else:
        updated = content.rstrip() + "\n\n" + block

    readme_path.write_text(updated + "\n", encoding="utf-8")


def main() -> None:
    projects = collect_projects()
    cards = []
    for item in projects:
        cards.append(
            build_card(
                item["folder"],
                item["title"],
                item["emoji"],
                item["description"],
                item["href"],
            )
        )

    html = HTML_TEMPLATE.format(cards="\n".join(cards))
    (ROOT / "index.html").write_text(html + "\n", encoding="utf-8")
    update_readme(projects)


if __name__ == "__main__":
    main()
