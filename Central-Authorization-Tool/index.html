<!--
  NOTE: This file was fully generated by AI (ChatGPT).
  For testing purposes only.
  Adjusted: token masking, improved panels, copy feedback, soft auto-refresh.
-->

<!DOCTYPE html>
<html>
<head>
  <title>Full Test Console</title>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <link rel="icon" href="../favicon.svg" type="image/svg+xml" />
  <style>
    :root {
      --bg: #f6f4f1;
      --text: #1f2328;
      --muted: #5b6168;
      --card: #ffffff;
      --accent: #0b66c3;
      --accent-hover: #094f98;
      --border: rgba(0,0,0,0.08);
      --shadow: 0 20px 50px rgba(17, 24, 39, 0.12);
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Trebuchet MS", "Segoe UI", Arial, sans-serif;
      margin: 0;
      padding: 28px 32px 48px;
      line-height: 1.55;
      background: radial-gradient(circle at top, #ffffff 0%, #f6f4f1 45%, #efe8df 100%);
      color: var(--text);
      transition: background 0.3s, color 0.3s;
    }
    form, .panel {
      border: 1px solid var(--border);
      padding: 16px 18px;
      margin-bottom: 20px;
      border-radius: 18px;
      background: var(--card);
      transition: background 0.3s, border-color 0.3s, box-shadow 0.3s;
      box-shadow: var(--shadow);
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    label {
      font-weight: 600;
    }
    input, select {
      margin-bottom: 10px;
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #ffffff;
      font-family: inherit;
    }
    button {
      cursor: pointer;
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid rgba(11, 102, 195, 0.3);
      background: var(--accent);
      color: #ffffff;
      font-weight: 600;
      transition: transform 0.15s ease, background 0.15s ease;
    }
    button:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }
    .section {
      margin-bottom: 25px;
    }
  /* userSection visibility controlled via JS; no default display block */
    details.panel {
      background: var(--card);
      padding: 0;
      overflow: hidden;
    }
    details.panel summary {
      list-style: none;
      cursor: pointer;
      font-size: 1.1rem;
      padding: 12px 16px;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(11, 102, 195, 0.08);
      border-bottom: 1px solid var(--border);
    }
    details.panel[open] summary {
      background: rgba(11, 102, 195, 0.12);
    }
    details.panel summary::-webkit-details-marker { display:none; }
    details.panel .content { padding: 16px 16px 10px; }
    details.panel .content h3:first-child { margin-top:0; }
    .badge {
      display:inline-block; padding:2px 8px; border-radius:20px; font-size:11px; background: rgba(11, 102, 195, 0.2); font-weight:600; color: var(--accent);
    }
    body.dark .badge { background:#444; }
    .token-masked { font-family: monospace; letter-spacing: 1px; }
    .inline-controls button { margin-left:6px; }
    .status-line { line-height:1.3; }
    /* Details open/close animation */
    details.panel .content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.45s ease;
    }
    details.panel[open] .content {
      max-height: 1200px; /* sufficiently large for content */
    }
    .validate-busy {
      opacity: 0.6;
      pointer-events: none;
    }
    .spinner-inline {
      display:inline-block; width:14px; height:14px; border:2px solid #999; border-top-color: transparent; border-radius:50%; animation: spin 0.7s linear infinite; vertical-align: middle; margin-left:6px;
    }
    @keyframes spin { to { transform: rotate(360deg);} }
    #authForm.fade-out { opacity:0; transition: opacity 0.4s ease; }
    #authForm[hidden] { display:none !important; }
    .meta-line { font-size:12px; opacity:0.85; margin-top:4px; }
    .inline-small { font-size:12px; }
    /* authStatus container basic styling */
    #authStatus {
      padding: 10px;
      font-weight: bold;
      border-radius: 12px;
      margin-bottom: 20px;
    }
    #authStatus.not-auth {
      background-color: #ffd6d6;
      color: #b30000;
    }
    #authStatus.auth {
      background-color: #d6ffd6;
      color: #006600;
    }
    #authStatus.rate-limited {
      background-color: #fff0d6; /* light orange */
      color: #8a4b00; /* dark orange text */
    }
    body.dark #authStatus.rate-limited {
      background-color: #553a20;
      color: #ffdca8;
    }
    /* Danger knop styling */
    .danger {
      background:#c62828;
      color:#fff;
      border:1px solid #b71c1c;
      padding:8px 14px;
      border-radius:6px;
      font-weight:600;
    }
    .danger:hover { background:#b71c1c; }
    body.dark .danger { background:#b71c1c; border-color:#8e1515; }
    body.dark .danger:hover { background:#a11919; }
    #logoutBtn, #validateBtn, #copyBtn, #darkModeBtn {
      margin-left: 10px;
      padding: 6px 12px;
    }
    #output {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid var(--border);
      background: #ffffff;
      border-radius: 12px;
      max-height: 400px;
      overflow-y: auto;
      transition: background 0.3s, border-color 0.3s;
    }
    pre {
      margin: 0;
      font-family: monospace;
      white-space: pre-wrap;
    }

  /* ---- DARK MODE ---- */
    body.dark {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    body.dark input, body.dark select, body.dark button {
      background: #2f2f2f;
      color: #e0e0e0;
      border: 1px solid #555;
    }
    body.dark button:hover {
      background:#3a3a3a;
    }
    body.dark form {
      background: #2b2b2b;
      border-color: #444;
    }
    body.dark details.panel { background:#262626; border-color:#444; }
    body.dark details.panel summary {
      background: linear-gradient(145deg,#2a2a2a,#242424);
      border-color:#333;
    }
    body.dark details.panel[open] summary {
      background: linear-gradient(145deg,#333,#2a2a2a);
    }
    body.dark form, body.dark .panel { background:#262626; border-color:#444; }
    body.dark #output { background:#1f1f1f; border-color:#444; }
    body.dark .token-masked { color:#dcdcdc; }
    body.dark .meta-line { color:#bbb; }
    body.dark #authStatus.not-auth {
      background-color: #5c2b2b;
      color: #ffaaaa;
    }
    body.dark #authStatus.auth {
      background-color: #2b5c2b;
      color: #aaffaa;
    }
  /* authForm visibility controlled via JS (fade-out + hidden) */
  </style>
</head>
<body>

<!-- Init script moved to end of body -->

  <!-- Status always on top -->
  <div id="authStatus" class="not-auth">üî¥ Not Authorized</div>

  <!-- Title always visible -->
  <h1>
    Full Test Console 
    <button id="darkModeBtn" onclick="toggleDarkMode()" aria-label="Toggle Dark Mode">üåô Dark Mode</button>
  </h1>
  <!-- Registry Section (starts collapsed) -->
  <details class="panel" id="registrySection">
    <summary>üì¶ Registry Management <span class="badge">registry</span></summary>
    <div class="content">
      <div id="registryForms">
        <h3>Create Registry</h3>
        <label>App Name:</label>
        <input id="appName" type="text" placeholder="my_app" />
        <label>Owner Username:</label>
        <input id="registryUsername" type="text" placeholder="owner username">
        <label>Owner Email:</label>
        <input id="registryEmail" type="email" placeholder="owner email (optional)">
        <label>Owner Password:</label>
        <input id="registryPassword" type="password" placeholder="owner password">
        <label>Owner Auth Level:</label>
        <input id="registryAuthLevel" type="number" min="0" step="1" placeholder="integer auth level (optional)">
        <!-- Origin token input removed: server expects AO-Addition-Token header, not a payload field -->
        <button id="createRegistryBtn" type="button">Create Registry</button>
        <hr>
        <h3>Lookup Registry</h3>
        <label>Database ID:</label>
        <input id="lookupDbId" type="text" placeholder="db id" />
        <button id="lookupRegistryBtn" type="button">Lookup</button>
        <hr>
        <h3>Authenticate Registry</h3>
        <label>Database ID:</label>
        <input id="authDbId" type="text" placeholder="db id" />
        <label>Registry Token:</label>
        <input id="registryToken" type="text" placeholder="token" />
        <button id="authRegistryBtn" type="button">Authenticate Registry</button>
      </div>
    </div>
  </details>

  <!-- (Removed) Global submit handler replaced by targeted listeners at end of body -->

  <!-- Authentication form (always displayed before login) -->
  <div id="authForm" data-form="auth">
    <h3>User Authentication</h3>
    <div id="demoLoginNote" class="meta-line">Demo login: <strong>Username:</strong> <code>DemoUser101</code> &nbsp; (<strong>Email:</strong> <code>DemoEmail@jvm.place</code>) &nbsp; <strong>Password:</strong> <code>1234</code> &nbsp; <strong>DB id:</strong> <code>-</code></div>
    <label>Target Database ID:</label>
  <input id="authDbIdUsers" type="text" required>

    <label>Username or Email:</label>
  <input id="usernameOrEmail" type="text" required>

    <label>Password:</label>
  <input id="authPassword" type="password" required>

    <label>Time Extension (minutes):</label>
  <input id="timeExtension" type="number" value="30" required>

    <button id="authSubmitBtn" type="button">Authenticate User</button>
  </div>

  <!-- User Section (starts collapsed) -->
  <details class="panel" id="userSection">
    <summary>üë• User Management <span class="badge">users</span></summary>
    <div class="content">
      <div id="userForm" data-form="user">
        <h3>User CRUD Operations</h3>
        <div class="field" data-field="dbId">
          <label for="dbId">Target Database ID:</label>
          <input id="dbId" type="text" required>
        </div>
        <div class="field" data-field="identifier">
          <label for="identifier">Identifier (username/email/ID):</label>
          <input id="identifier" type="text" placeholder="leave empty for list (GET)">
        </div>
        <div class="field" data-field="idMethod">
          <label for="idMethod">Identifier Method:</label>
          <select id="idMethod">
            <option value="username">Username</option>
            <option value="email">Email</option>
            <option value="id">ID (Identification Number)</option>
          </select>
        </div>
        <div class="field" data-field="username">
          <label for="username">Username:</label>
          <input id="username" type="text" autocomplete="off">
        </div>
        <div class="field" data-field="email">
          <label for="email">Email (optional):</label>
          <input id="email" type="email" autocomplete="off" placeholder="optional">
        </div>
        <div class="field" data-field="password">
          <label for="password">Password:</label>
          <input id="password" type="password" autocomplete="new-password">
        </div>
        <!-- Origin token removed: backend expects AO-Addition-Token header, not a JSON payload field -->
        <div class="field" data-field="authLevel">
          <label for="authLevel">Auth Level (integer):</label>
          <input id="authLevel" type="number" inputmode="numeric" step="1" min="0" placeholder="e.g. 0 = user, 1 = moderator, 5 = admin" list="authLevelOptions">
          <datalist id="authLevelOptions">
            <option value="0">User</option>
            <option value="1">Moderator</option>
            <option value="2">Manager</option>
            <option value="3">Support</option>
            <option value="5">Admin</option>
            <option value="10">Owner</option>
          </datalist>
        </div>
        <div class="field" data-field="requestType">
          <label for="requestType">Action:</label>
          <select id="requestType">
            <option value="GET">GET (List or Lookup)</option>
            <option value="POST">POST (Create)</option>
            <option value="PATCH">PATCH (Update)</option>
            <option value="DELETE">DELETE (Remove)</option>
          </select>
        </div>
        <div class="field" data-field="submitBtn">
          <button id="userSubmitBtn" type="button">Submit User Request</button>
        </div>
        <div class="field" data-field="selfDelete" style="display:none">
          <button id="selfDeleteBtn" type="button" class="danger">Delete My Account</button>
        </div>
      </div>
    </div>
  </details>

  <!-- Output area -->
  <h2>Response Output</h2>
  <div id="output"><pre>Responses will appear here...</pre></div>


  <!-- Load external configuration (API base URL, etc.) -->
  <script src="config.js"></script>

<script>
// ==== Config ====
// Prefer apiBase from global APP_CONFIG, fall back to default if missing
const apiBase = (window.APP_CONFIG && window.APP_CONFIG.apiBase) || "https://didactic-space-palm-tree-v6gw94rjqw6p3wp5v-5000.app.github.dev/";

// ==== Helpers ====
function formatTime(date) { return date.toLocaleString(); }
function showOutput(title, data) {
  const out = document.getElementById("output");
  if (!out) return;
  const pre = document.createElement('pre');
  const text = `${title}\n${JSON.stringify(data, null, 2)}`;
  pre.textContent = text; // render any HTML-like content as plain text
  out.innerHTML = "";
  out.appendChild(pre);
  try { localStorage.setItem('lastOutput', text); } catch(e) { /* ignore storage errors */ }
}
// Basic HTML-escaping helper for any dynamic text that must go into innerHTML
function escapeHtml(str) {
  if (str == null) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}
// Add helper to auto inject auth token header expected by the API
function authFetch(url, options = {}) {
  const token = localStorage.getItem('authToken');
  options.headers = options.headers || {};
  // API expects the raw token in the `X-Auth-Token` header (server reads this).
  if (token && !options.headers['X-Auth-Token']) {
    options.headers['X-Auth-Token'] = token;
  }
  // Ensure a db_id header is sent for registry requests (or use last known db id)
  try {
      if (!options.headers['db-id']) {
      let dbId = localStorage.getItem('lastDbId') || '';
      // try to extract db id from common registry URL patterns
      const m1 = url.match(/\/api\/registry\/authenticate\/([^\/]+)\//);
      const m2 = url.match(/\/api\/registry\/([^\/]+)\//);
      if (m1 && m1[1]) dbId = m1[1];
      else if (m2 && m2[1]) dbId = m2[1];
      if (dbId) {
        options.headers['db-id'] = dbId;
      }
    }
  } catch (e) {}
  return fetch(url, options);
}

// ==== Dark Mode ====
function toggleDarkMode() {
  document.body.classList.toggle("dark");
  const enabled = document.body.classList.contains("dark");
  localStorage.setItem("darkMode", enabled ? "1" : "0");
  document.getElementById("darkModeBtn").textContent = enabled ? "‚òÄÔ∏è Light Mode" : "üåô Dark Mode";
}
function initDarkMode() {
  if (localStorage.getItem("darkMode") === "1") {
    document.body.classList.add("dark");
    document.getElementById("darkModeBtn").textContent = "‚òÄÔ∏è Light Mode";
  }
}

// ==== Auth Status ====
function maskIfNeeded(token) {
  const mask = localStorage.getItem('maskToken') === '1';
  if (!mask) return token;
  if (!token || token.length <= 8) return '‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
  return token.slice(0,4)+ '‚Ä¶' + token.slice(-4);
}

function updateAuthStatus() {
  // If currently rate-limited, show a persistent rate-limit status and hide other UI
  if (window._rateLimitUntil && Date.now() < window._rateLimitUntil) {
    const statusDiv = document.getElementById("authStatus");
    const msLeft = Math.max(0, window._rateLimitUntil - Date.now());
    const sec = Math.ceil(msLeft / 1000);
    const token = localStorage.getItem("authToken");
    const dbId = localStorage.getItem("lastDbId");
    const lastValidatedRaw = localStorage.getItem("lastValidated");
    const userId = localStorage.getItem("userId");
    const userRole = localStorage.getItem("userRole");
    const masked = maskIfNeeded(token);
    let since = '';
    let lastDisplay = '';
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (!isNaN(d.getTime())) {
        const diff = Date.now() - d.getTime();
        const sec_age = Math.floor(diff/1000);
        const m = Math.floor(sec_age/60);
        const s = sec_age%60;
        since = ` (<span id='elapsedSinceValidate'>${m}m ${s}s</span> ago)`;
        lastDisplay = formatTime(d);
      } else {
        lastDisplay = lastValidatedRaw;
      }
    }
    let html = `üü† Rate Limited`+
      `<div class='status-line'>Token: <span class='token-masked'>${escapeHtml(masked)}</span>`+
      `<span class='inline-controls'>`+
      `<button id='copyBtn' type='button' onclick='copyToken()'>üìã Copy</button>`+
      `<button id='maskToggleBtn' type='button' onclick='toggleMask()'>${localStorage.getItem('maskToken')==='1'?'üëÅÔ∏è Show':'üôà Mask'}</button>`+
      `</span></div>`+
      `<div class='status-line'>DB: ${escapeHtml(dbId || '‚Äî')} <button id='logoutBtn' type='button' onclick='logout()'>Logout</button>`+
      `<button id='validateBtn' type='button' disabled>Validate Token</button></div>`+
      (userId? `<br>User ID: ${escapeHtml(userId)}` : '') +
      (userRole? `<br>Role: ${escapeHtml(userRole)}` : '') +
      (lastDisplay? `<br><i>Last validated: ${lastDisplay}${since}</i>` : '') +
      `<br><b>Retry in <span id='rateLimitCountdown'>${sec}s</span></b>`;
    statusDiv.innerHTML = html;
    statusDiv.className = "rate-limited";
    // hide the main interactive sections to emphasize waiting state
    const userSection = document.getElementById("userSection");
    const registrySection = document.getElementById("registrySection");
    const af = document.getElementById("authForm");
    if (userSection) userSection.style.display = "none";
    if (registrySection) registrySection.style.display = "none";
    if (af) { af.setAttribute('hidden','hidden'); af.classList.remove('fade-out'); }
    return;
  }
  const token = localStorage.getItem("authToken");
  const dbId = localStorage.getItem("lastDbId");
  const lastValidatedRaw = localStorage.getItem("lastValidated"); // now stored as ISO
  const userId = localStorage.getItem("userId");
  const userRole = localStorage.getItem("userRole");
  const statusDiv = document.getElementById("authStatus");
  const userSection = document.getElementById("userSection");
  const registrySection = document.getElementById("registrySection");
  // debug artifacts removed earlier
  if (token && dbId) {
    const masked = maskIfNeeded(token);
    let since = '';
    let lastDisplay = '';
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (!isNaN(d.getTime())) {
        const diff = Date.now() - d.getTime();
        const sec = Math.floor(diff/1000);
        const m = Math.floor(sec/60);
        const s = sec%60;
        since = ` (<span id='elapsedSinceValidate'>${m}m ${s}s</span> ago)`;
        lastDisplay = formatTime(d);
      } else {
        // fallback: if parsing fails, show raw stored value
        lastDisplay = lastValidatedRaw;
      }
    }
    let html = `üü¢ Authorized`+
      `<div class='status-line'>Token: <span class='token-masked'>${escapeHtml(masked)}</span>`+
      `<span class='inline-controls'>`+
      `<button id='copyBtn' type='button' onclick='copyToken()'>üìã Copy</button>`+
      `<button id='maskToggleBtn' type='button' onclick='toggleMask()'>${localStorage.getItem('maskToken')==='1'?'üëÅÔ∏è Show':'üôà Mask'}</button>`+
      `</span></div>`+
      `<div class='status-line'>DB: ${escapeHtml(dbId)} <button id='logoutBtn' type='button' onclick='logout()'>Logout</button>`+
      `<button id='validateBtn' type='button' onclick='validateToken()'>Validate Token</button></div>`;
    if (userId) html += `<br>User ID: ${escapeHtml(userId)}`;
    if (userRole) html += `<br>Role: ${escapeHtml(userRole)}`;
    if (lastDisplay) html += `<br><i>Last validated: ${escapeHtml(lastDisplay)}${since}</i>`;
    statusDiv.innerHTML = html;
    statusDiv.className = "auth";
    autoFillDbId(dbId);
    if (userSection) { userSection.style.display = ""; }
    if (registrySection) { registrySection.style.display = ""; }
    const af = document.getElementById("authForm");
    if (af && !af.hasAttribute('hidden')) {
      af.classList.add('fade-out');
      setTimeout(()=>{ af.setAttribute('hidden','hidden'); }, 350);
    }
    updateUserFormVisibility();
  } else {
    let msg = "üî¥ Not Authorized";
  	if (window._showUnauthMsg) msg += "<br><b>You have been logged out or the session expired.</b>";
    statusDiv.innerHTML = msg;
    statusDiv.className = "not-auth";
    window._showUnauthMsg = false;
    if (userSection) userSection.style.display = "none";
    if (registrySection) registrySection.style.display = "none";
    const af = document.getElementById("authForm");
    if (af) { af.removeAttribute('hidden'); af.classList.remove('fade-out'); }
  }
}

function logout() {
  ["authToken","lastDbId","lastValidated","userId","userRole"].forEach(k=>localStorage.removeItem(k));
  window._showUnauthMsg = true;
  // Force show auth form immediately
  const af = document.getElementById('authForm');
  if (af) {
    af.removeAttribute('hidden');
    af.classList.remove('fade-out');
    af.style.display = '';
  }
  // Clear any active rate-limit state so logout overrides rate-limited UI
  try { delete window._rateLimitUntil; } catch(e) { window._rateLimitUntil = 0; }
  try { delete window._rateLimitAnnounced; } catch(e) { window._rateLimitAnnounced = false; }
  // Update UI now
  updateAuthStatus();
  showOutput("Logout", {status:"ok"});
}
function copyToken() {
  const token = localStorage.getItem("authToken");
  if (!token) return;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(token).then(showCopyHint).catch(()=>fallbackCopy(token));
  } else {
    fallbackCopy(token);
  }
}
function showCopyHint(){
  let hint = document.getElementById('copyHint');
  if (!hint) {
    hint = document.createElement('div');
    hint.id = 'copyHint';
    hint.style.position = 'fixed';
    hint.style.top = '12px';
    hint.style.right = '16px';
    hint.style.background = 'rgba(40,40,40,0.85)';
    hint.style.color = '#fff';
    hint.style.padding = '6px 12px';
    hint.style.borderRadius = '6px';
    hint.style.fontSize = '13px';
    hint.style.fontFamily = 'system-ui, Arial, sans-serif';
    hint.style.zIndex = '9999';
    hint.style.opacity = '0';
    hint.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
    hint.style.transform = 'translateY(-6px)';
    hint.textContent = 'Copied!';
    document.body.appendChild(hint);
  }
  // reset animation
  void hint.offsetWidth;
  hint.style.opacity = '1';
  hint.style.transform = 'translateY(0)';
  clearTimeout(window._copyHintTimer);
  window._copyHintTimer = setTimeout(()=>{
    hint.style.opacity='0';
    hint.style.transform='translateY(-6px)';
  }, 1600);
}
  function fallbackCopy(text){
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position='fixed';
      ta.style.top='-1000px';
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      showCopyHint();
    } catch(e){ console.warn('Fallback copy failed', e); }
  }
function toggleMask(){
  const cur = localStorage.getItem('maskToken')==='1';
  localStorage.setItem('maskToken', cur? '0':'1');
  updateAuthStatus();
}

// ==== Rate Limit Helper ====
function setRateLimitCooldown(res, info){
  // Accept either a Response or a numeric/string message in res
  let ms = 30000; // default 30s
  try {
    if (res) {
      // If res is a Response, try headers Retry-After first
      if (res.headers && typeof res.headers.get === 'function') {
        const ra = res.headers.get('Retry-After');
        if (ra) {
          const sec = parseInt(ra,10);
          if (!isNaN(sec)) ms = sec * 1000;
          else {
            // Retry-After can be a HTTP date ‚Äî try Date parse
            const d = Date.parse(ra);
            if (!isNaN(d)) ms = Math.max(0, d - Date.now());
          }
        }
      }
      // If info param provided and contains textual info, use it first
      let text = null;
      if (info) {
        if (typeof info === 'string') text = info;
        else if (info && info.message && typeof info.message === 'string') text = info.message;
        else if (info && info.error && typeof info.error === 'string') text = info.error;
      }
      // Otherwise, try to derive text from res
      if (!text) {
        if (typeof res === 'string') text = res;
        else if (res && res.message && typeof res.message === 'string') text = res.message;
        else if (res && res.error && typeof res.error === 'string') text = res.error;
      }
      // If no text yet and Response is cloneable, attempt to read a short text (non-blocking best-effort)
      if (!text && res && typeof res.clone === 'function') {
        try {
          // clone and read without awaiting caller (best-effort)
          res.clone().text().then(t => {
            try { parseRateTextAndSet(t); } catch(e){}
          }).catch(()=>{});
        } catch(e){}
      }
      if (text) {
        // parse patterns like '10 per 1 minute' or '2 per 1 second'
        const m = text.match(/per\s+(\d+)\s*(second|minute|hour)s?/i);
        if (m) {
          const num = parseInt(m[1],10);
          const unit = m[2].toLowerCase();
          const unitSec = unit.startsWith('second') ? 1 : unit.startsWith('minute') ? 60 : 3600;
          ms = unitSec * num * 1000;
        }
      }
    }
  } catch(e) {
    // fallback to default
    ms = 30000;
  }
  // helper used by async clone read above
  function parseRateTextAndSet(t) {
    const m = (t||'').match(/per\s+(\d+)\s*(second|minute|hour)s?/i);
    if (m) {
      const num = parseInt(m[1],10);
      const unit = m[2].toLowerCase();
      const unitSec = unit.startsWith('second') ? 1 : unit.startsWith('minute') ? 60 : 3600;
      window._rateLimitUntil = Date.now() + unitSec * num * 1000;
      window._rateLimitAnnounced = false;
    }
  }
  window._rateLimitUntil = Date.now() + ms;
  window._rateLimitAnnounced = false; // reset announcement flag
}

// ==== Auth ====
async function authenticateUser(e) {
  if (e) e.preventDefault();
  console.log("[Auth] submit start");
  const dbId = document.getElementById("authDbIdUsers").value.trim();
  const usernameOrEmail = document.getElementById("usernameOrEmail").value.trim();
  const password = document.getElementById("authPassword").value;
  const timeExtension = document.getElementById("timeExtension").value || 30;
  const statusDiv = document.getElementById("authStatus");
  try {
    // changed scheme: use 'create' instead of '0'
    const url = `${apiBase}api/${dbId}/users/authenticate/create/${timeExtension}/`;
    const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({username_or_email: usernameOrEmail, password})});
    let data = null;
    try { data = await res.json(); } catch(parseErr){ data = {error:"Invalid JSON response", detail: parseErr+""}; }
    console.log("[Auth] response", res.status, data);
    if (res.status === 429) {
      setRateLimitCooldown(res, data);
      showOutput("Rate Limit", data || {error:"Too Many Requests"});
      updateAuthStatus();
      return false; // do not logout
    }
    if (res.status === 401 || res.status === 403) {
      logout();
      throw new Error(data && data.error ? data.error : `HTTP ${res.status}`);
    }
    if (!res.ok) {
      // 500 and other errors: do not logout, just show error
      showOutput("Auth HTTP Error", data || {status:res.status});
      return false;
    }
    if (data && data.auth_token) {
      localStorage.setItem("authToken", data.auth_token);
      localStorage.setItem("lastDbId", dbId);
      // store ISO timestamp for reliable parsing
      localStorage.setItem("lastValidated", new Date().toISOString());
      if (data.user_id) localStorage.setItem("userId", data.user_id);
      if (data.auth_level) localStorage.setItem("userRole", data.auth_level);
      showOutput("User Auth", data);
      updateAuthStatus();
    } else {
  throw new Error(data && data.error ? data.error : "Unknown authentication error");
    }
  } catch(err) {
    console.warn("[Auth] error", err);
	const safeErr = escapeHtml(err+"");
	statusDiv.innerHTML = `üî¥ Not Authorized<br><b>Authentication error: ${safeErr}</b>`;
    statusDiv.className = "not-auth";
    showOutput("Auth Error", {error: err+""});
  }
  return false;
}

async function validateToken() {
  // If still rate-limited, announce and update UI
  if (window._rateLimitUntil && Date.now() < window._rateLimitUntil) {
    if (!window._rateLimitAnnounced) {
      showOutput('Rate Limit Cooldown', {until: new Date(window._rateLimitUntil).toLocaleTimeString()});
      window._rateLimitAnnounced = true;
    }
    updateAuthStatus();
    return;
  }

  const validateBtn = document.getElementById('validateBtn');
  if (validateBtn && !validateBtn.classList.contains('validate-busy')) {
    validateBtn.classList.add('validate-busy');
    const original = validateBtn.textContent;
    validateBtn.setAttribute('data-orig', original);
    validateBtn.textContent = 'Validating';
    const spinner = document.createElement('span');
    spinner.className='spinner-inline';
    validateBtn.appendChild(spinner);
  }

  const token = localStorage.getItem("authToken");
  const dbId = localStorage.getItem("lastDbId");
  if (!token || !dbId) { showOutput("Validation Error", {error:"Missing token or DB."});
    if (validateBtn) setTimeout(()=>{ validateBtn.classList.remove('validate-busy'); const sp=validateBtn.querySelector('.spinner-inline'); if (sp) sp.remove(); validateBtn.textContent = validateBtn.getAttribute('data-orig') || 'Validate Token'; }, 50);
    return; }

  // perform validation and always clear spinner/busy state afterwards
  try {
    const url = `${apiBase}api/${dbId}/users/authenticate/curr/2/`;
    const userId = localStorage.getItem("userId") || "";
    const res = await authFetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({user_id: userId})});
    let data = null; try { data = await res.json(); } catch(e){ data={error:"Invalid JSON"}; }
    if (res.status === 429) { setRateLimitCooldown(res, data); showOutput("Rate Limit", data || {error:"Too Many Requests"}); updateAuthStatus(); return; }
    if (res.status === 401 || res.status === 403) { logout(); throw new Error(data && data.error ? data.error : `HTTP ${res.status}`); }
    if (!res.ok || !data || !data.auth_token) { showOutput("Validation HTTP Error", data || {status:res.status}); return; }
    localStorage.setItem("authToken", data.auth_token);
    // store ISO timestamp for reliable parsing
    localStorage.setItem("lastValidated", new Date().toISOString());
    if (data.user_id) localStorage.setItem("userId", data.user_id);
    if (data.auth_level) localStorage.setItem("userRole", data.auth_level);
    showOutput("Token Validation", data);
    updateAuthStatus();
  } catch(err) {
    showOutput("Validation Error", {error: err+""});
  } finally {
    if (validateBtn) {
      try {
        const orig = validateBtn.getAttribute('data-orig') || 'Validate Token';
        validateBtn.textContent = orig;
        validateBtn.classList.remove('validate-busy');
        const sp = validateBtn.querySelector('.spinner-inline'); if (sp) sp.remove();
      } catch(e){}
    }
  }
}

// ==== Users CRUD ====
async function sendUserRequest(e) {
  if (e) e.preventDefault();
  console.log("[UserRequest] submit start");
  const dbId = document.getElementById("dbId").value.trim();
  const identifier = document.getElementById("identifier").value.trim();
  const idMethod = document.getElementById("idMethod").value;
  const username = document.getElementById("username").value.trim();
  const email = document.getElementById("email").value.trim();
  const password = document.getElementById("password").value;
  // originToken removed: backend does not accept a token in the JSON body
  // Replace string role with integer-only input parsing
  const authLevelRaw = document.getElementById("authLevel").value;
  const authLevelNum = authLevelRaw === '' ? null : parseInt(authLevelRaw, 10);
  if (authLevelRaw !== '' && (!Number.isFinite(authLevelNum) || !Number.isInteger(authLevelNum))) {
    return showOutput("Validation Error", {error:"Auth level must be an integer."});
  }
  const requestType = document.getElementById("requestType").value;
  const token = localStorage.getItem("authToken");
  const userId = localStorage.getItem("userId");
  // const userRole = localStorage.getItem("userRole");
  const statusDiv = document.getElementById("authStatus");
  if (!dbId) return showOutput("Validation Error", {error:"Database ID required."});
  if (requestType === 'POST') {
    if (!username) return showOutput("Validation Error", {error:"Username required (POST)."});
    if (!password) return showOutput("Validation Error", {error:"Password required (POST)."});
  }

  const base = `${apiBase}api/${dbId}/users/`;
  const headers = {"Content-Type":"application/json"};
  // Authorization now auto added by authFetch

  // Build payload dynamically
  const userData = {};
  if (requestType === 'POST') {
    userData.username = username;
    if (email) userData.email = email;
    userData.password = password;
    if (authLevelNum !== null) userData.auth_level = authLevelNum;
  } else if (requestType === 'PATCH') {
    if (!identifier) return showOutput("Validation Error", {error:"Identifier required (PATCH)."});
    if (!password) return showOutput("Validation Error", {error:"Password required (PATCH)."});
    if (username) userData.username = username;
    if (email) userData.email = email;
    userData.password = password;
    if (authLevelNum !== null) userData.auth_level = authLevelNum;
    if (Object.keys(userData).length === 0) return showOutput("Validation Error", {error:"No changes supplied."});
  }
  try {
    if (requestType === "POST") {
      const res = await authFetch(base, {method:"POST", headers, body: JSON.stringify(userData)});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("User Created", data); resetUserForm(); return false;
    }
    if (requestType === "DELETE") {
      if (!identifier) return showOutput("Validation Error", {error:"Identifier required."});
      // Block DELETE for protected user by id, username, or email
      const protectedId = "1bed1bf829cb9036ba9a19b96ffdbc86";
      const protectedUsername = "DemoUser101";
      const protectedEmail = "DemoEmail@jvm.place";
      if (
        identifier === protectedId ||
        identifier === protectedUsername ||
        identifier === protectedEmail
      ) {
        return showOutput("DELETE Error", {error:"This user cannot be deleted."});
      }
      const res = await authFetch(base+idMethod+`/${identifier}/`, {method:"DELETE", headers});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("User Deleted", data); resetUserForm(); return false;
    }
    if (requestType === "PATCH") {
      if (!identifier) return showOutput("Validation Error", {error:"Identifier required."});
      // Block PATCH for protected user by id, username, or email
      const protectedId = "1bed1bf829cb9036ba9a19b96ffdbc86";
      const protectedUsername = "DemoUser101";
      const protectedEmail = "DemoEmail@jvm.place";
      if (
        identifier === protectedId ||
        identifier === protectedUsername ||
        identifier === protectedEmail
      ) {
        return showOutput("PATCH Error", {error:"This user cannot be patched."});
      }
      const res = await authFetch(base+idMethod+`/${identifier}/`, {method:"PATCH", headers, body: JSON.stringify(userData)});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("User Updated", data); resetUserForm(); return false;
    }
    if (requestType === "GET") {
      let url = base; if (identifier) url += idMethod+`/${identifier}/`;
      const res = await authFetch(url, {headers});
      if (res.status === 429) {
        let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){}
        setRateLimitCooldown(res, bodyText || undefined);
        showOutput("Rate Limit", {error:"Too Many Requests"}); updateAuthStatus(); return false; }
      if (res.status === 401 || res.status === 403) { logout(); return; }
      const data = await res.json(); showOutput("GET Result", data); return false;
    }
  } catch(err) { showOutput("User Request Error", {error: err+""}); }
  return false;
}

function resetUserForm() {
  ["username","email","password","identifier"].forEach(id=>{
    const el=document.getElementById(id);
    if (el) el.value="";
  });
}

function updateUserFormVisibility() {
  const requestTypeSelect = document.getElementById("requestType");
  if (!requestTypeSelect) return;
  const action = requestTypeSelect.value;
  const field = name => document.querySelector(`.field[data-field='${name}']`);
  const show = (name, cond) => { const el = field(name); if (el) el.style.display = cond ? '' : 'none'; };

  // Base visibility defaults
  show('dbId', true);
  show('requestType', true);
  show('submitBtn', true);
  show('identifier', false);
  show('idMethod', false);
  show('username', false);
  show('email', false);
  show('password', false);
  show('authLevel', false);
  show('selfDelete', true); // available to all; backend authorizes

  // No role-based hiding of options
  if (action === 'GET') {
    show('identifier', true);
    show('idMethod', true);
  } else if (action === 'POST') {
    show('username', true);
    show('email', true);
    show('password', true);
    show('authLevel', true);
  } else if (action === 'PATCH') {
    show('identifier', true);
    show('idMethod', true);
    show('username', true);
    show('email', true);
    show('password', true);
    show('authLevel', true);
  } else if (action === 'DELETE') {
    show('identifier', true);
    show('idMethod', true);
  }
}

// Self deletion without identifier input for non-admins
async function deleteOwnAccount(){
  // Removed frontend role gate; backend enforces
  const token = localStorage.getItem('authToken');
  const dbId = localStorage.getItem('lastDbId') || document.getElementById('dbId').value.trim();
  const userId = localStorage.getItem('userId');
  if (!token || !dbId || !userId) return showOutput('Self Delete Error', {error:'Missing token / dbId / userId'});
  if (!confirm('Are you sure you want to delete your account? This cannot be undone.')) return;
  try {
    const res = await authFetch(`${apiBase}api/${dbId}/users/id/${userId}/`, {method:'DELETE'});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    if (res.status === 401 || res.status === 403) { logout(); return; }
    let data=null; try { data = await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Self Delete Result', data);
    if (res.ok) {
      logout();
    }
  } catch(err){ showOutput('Self Delete Error', {error: err+''}); }
}

function autoFillDbId(dbId) {
  if (!dbId) return;
  ["dbId","authDbIdUsers"].forEach(id=>{ const el=document.getElementById(id); if (el && !el.value) el.value=dbId; });
}

// legacy collapsible (no longer needed after details) placeholder
function setupCollapsibles() {}

// ==== Registry Functions ====
async function createRegistry(){
  const appName = document.getElementById('appName').value.trim();
  const ownerUsername = document.getElementById('registryUsername').value.trim();
  const ownerEmail = document.getElementById('registryEmail').value.trim();
  const ownerPassword = document.getElementById('registryPassword').value;
  const ownerAuthLevelRaw = document.getElementById('registryAuthLevel').value;
  // registryOriginToken input removed from UI; AO-Addition-Token is sent via header when needed
  if(!appName) { showOutput('Registry Create Error', {error:'App name required'}); return; }
  if(!ownerUsername || !ownerPassword) {
    showOutput('Registry Create Error', {error:'Owner username and password required'});
    return;
  }
  const payload = {
    app_name: appName,
    username: ownerUsername,
    password: ownerPassword
  };
  if(ownerEmail) payload.email = ownerEmail;
  if(ownerAuthLevelRaw !== '') {
    const lvl = parseInt(ownerAuthLevelRaw, 10);
    if(Number.isInteger(lvl)) payload.auth_level = lvl;
    else return showOutput('Registry Create Error', {error:'Owner auth level must be an integer'});
  }
  try {
    const headers = {'Content-Type':'application/json'};
    const lastDb = localStorage.getItem('lastDbId');
    if (lastDb) headers['db-id'] = lastDb;
    const res = await authFetch(`${apiBase}api/registry/`, {method:'POST', headers, body: JSON.stringify(payload)});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Created', data);
    if(res.ok && data && data.database_id){
      localStorage.setItem('lastDbId', data.database_id);
      autoFillDbId(data.database_id);
      updateAuthStatus();
      ['appName','registryUsername','registryEmail','registryPassword','registryAuthLevel'].forEach(id=>{
        const el=document.getElementById(id); if(el) el.value='';
      });
    }
  } catch(err){ showOutput('Registry Create Error', {error: err+''}); }
}
async function lookupRegistry(){
  const id = document.getElementById('lookupDbId').value.trim();
  if(!id){ showOutput('Registry Lookup Error', {error:'Database ID required'}); return; }
  try {
    const headers = {};
    // use the DB the user is logged into when available, otherwise fall back to the looked-up id
    const lastDb = localStorage.getItem('lastDbId');
    headers['db-id'] = lastDb || id;
    const res = await authFetch(`${apiBase}api/registry/${id}/`, {method:'GET', headers});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Lookup', data);
  } catch(err){ showOutput('Registry Lookup Error', {error: err+''}); }
}
async function authenticateRegistry(){
  const dbId = document.getElementById('authDbId').value.trim();
  const tokenPlain = document.getElementById('registryToken').value.trim();
  if(!dbId || !tokenPlain){ showOutput('Registry Auth Error', {error:'DB id and token both required'}); return; }
  try {
    // The backend expects the AO addition token in the `AO-Addition-Token` header
    // and the route requires a 'method' segment. We use 'token' as the method.
    const res = await authFetch(`${apiBase}api/registry/authenticate/${dbId}/token/`, {method:'GET', headers: {'AO-Addition-Token': tokenPlain}});
    if (res.status === 429) { let bodyText = null; try { bodyText = await res.clone().text(); } catch(e){} setRateLimitCooldown(res, bodyText || undefined); showOutput('Rate Limit', {error:'Too Many Requests'}); return; }
    let data=null; try { data=await res.json(); } catch(e){ data={error:'Invalid JSON'}; }
    showOutput('Registry Auth', data);
  } catch(err){ showOutput('Registry Auth Error', {error: err+''}); }
}

// ==== Init ====

// ==== Soft Auto Refresh ====
function scheduleSoftRefresh(){
  // Runs every minute: if token older than threshold or >4min since last validation, revalidate; else refresh UI
  if (window._softRefreshTimer) clearInterval(window._softRefreshTimer);
  // We now convert to a per-second engine for both countdown and elapsed update.
  window._softRefreshTimer = setInterval(()=>{
    const token = localStorage.getItem('authToken');
    const lastValidatedRaw = localStorage.getItem('lastValidated');
    if (!token) return; // nothing to do
    // If a rate-limit cooldown exists and has expired, clear it and update UI
    if (window._rateLimitUntil) {
      const msLeftCheck = window._rateLimitUntil - Date.now();
      if (msLeftCheck <= 0) {
        try { delete window._rateLimitUntil; } catch(e){ window._rateLimitUntil = 0; }
        try { delete window._rateLimitAnnounced; } catch(e){ window._rateLimitAnnounced = false; }
        updateAuthStatus();
        // continue normal loop after clearing
      } else {
        // Still rate-limited: update the rate-limited UI and countdown
        updateAuthStatus();
        if (lastValidatedRaw) {
          const d = new Date(lastValidatedRaw);
          if (!isNaN(d.getTime())) {
            const ageMs = Date.now() - d.getTime();
            const sec = Math.floor(ageMs/1000);
            const m = Math.floor(sec/60);
            const s = sec%60;
            const elapsedSpan = document.getElementById('elapsedSinceValidate');
            if (elapsedSpan) elapsedSpan.textContent = `${m}m ${s}s`;
          }
        }
        const msLeft = Math.max(0, window._rateLimitUntil - Date.now());
        const secLeft = Math.ceil(msLeft/1000);
        const rl = document.getElementById('rateLimitCountdown'); if (rl) rl.textContent = `${secLeft}s`;
        return;
      }
    }
    let needRevalidate = false;
    let nextCountdown = '--';
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (!isNaN(d.getTime())) {
        const ageMs = Date.now() - d.getTime();
        const threshold = 4 * 60 * 1000; // 4 minutes
        const remaining = threshold - ageMs;
        if (remaining <= 0) {
          needRevalidate = true;
        } else {
          const rSec = Math.max(0, Math.floor(remaining/1000));
          const m = Math.floor(rSec/60);
          const s = rSec % 60;
          nextCountdown = `${m}m ${s}s`;
        }
        // update elapsedSinceValidate span if exists
        const elapsedSpan = document.getElementById('elapsedSinceValidate');
        if (elapsedSpan) {
          const sec = Math.floor(ageMs/1000);
          const m = Math.floor(sec/60);
          const s = sec%60;
          elapsedSpan.textContent = `${m}m ${s}s`;
        }
        const nextSpan = document.getElementById('nextValidationCountdown');
        if (nextSpan) nextSpan.textContent = nextCountdown;
      } else {
        needRevalidate = true; // unparseable -> force revalidate
      }
    } else {
      needRevalidate = true; // no timestamp yet
    }
    if (needRevalidate) {
      validateToken();
    }
  }, 1000);
}

window.addEventListener("DOMContentLoaded", ()=>{
  setupCollapsibles(); // noop
  initDarkMode();
  // restore last output (helps keep logs after refreshes)
  try {
    const last = localStorage.getItem('lastOutput');
    if (last) {
    const out = document.getElementById('output');
    if (out) {
      const pre = document.createElement('pre');
      pre.textContent = last; // treat stored output as plain text
      out.innerHTML = '';
      out.appendChild(pre);
    }
    }
  } catch(e) {}
  // Directly show sections if a token already exists on reload
  if (localStorage.getItem('authToken') && localStorage.getItem('lastDbId')) {
    const us = document.getElementById('userSection'); if (us) { us.style.display=''; }
    const rf = document.getElementById('registrySection'); if (rf) { rf.style.display=''; }
    const af = document.getElementById('authForm');
    if (af) af.style.display='none';
  }
  updateAuthStatus();
  const authBtn = document.getElementById('authSubmitBtn');
  const userBtn = document.getElementById('userSubmitBtn');
  const regCreate = document.getElementById('createRegistryBtn');
  const regLookup = document.getElementById('lookupRegistryBtn');
  const regAuth = document.getElementById('authRegistryBtn');
  if (authBtn) authBtn.addEventListener('click', authenticateUser);
  if (userBtn) userBtn.addEventListener('click', sendUserRequest);
  if (regCreate) regCreate.addEventListener('click', createRegistry);
  if (regLookup) regLookup.addEventListener('click', lookupRegistry);
  if (regAuth) regAuth.addEventListener('click', authenticateRegistry);
  const select = document.getElementById("requestType");
  if (select) { select.addEventListener("change", updateUserFormVisibility); updateUserFormVisibility(); }
  const selfDel = document.getElementById('selfDeleteBtn');
  if (selfDel) selfDel.addEventListener('click', deleteOwnAccount);
  const ident = document.getElementById('identifier');
  if (ident) ident.addEventListener('input', ()=>{
    if (document.getElementById('requestType').value === 'GET') updateUserFormVisibility();
  });
  // Prevent any <form> default submits from reloading the page
  window.addEventListener('submit', function(e){ e.preventDefault(); });
  // Auto validate token after 5 minutes (initial check)
  const token = localStorage.getItem("authToken");
  const lastValidatedRaw = localStorage.getItem("lastValidated");
  if (token) {
    let shouldValidate = false;
    if (lastValidatedRaw) {
      const d = new Date(lastValidatedRaw);
      if (isNaN(d.getTime())) shouldValidate = true;
      else if (Date.now() - d.getTime() > 300000) shouldValidate = true;
    } else shouldValidate = true;
    if (shouldValidate) validateToken();
  }
  scheduleSoftRefresh();
  // init done
});
</script>

</body>
</html>
